<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quantum++: qpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quantum++
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">A modern C++11 quantum computing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceqpp.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Quantum++ main namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceqpp_1_1exception"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1exception.html">exception</a></td></tr>
<tr class="memdesc:namespaceqpp_1_1exception"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantum++ exception hierarchy namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqpp_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1experimental.html">experimental</a></td></tr>
<tr class="memdesc:namespaceqpp_1_1experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental/test functions/classes, do not use or modify. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqpp_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespaceqpp_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal utility functions, do not use them directly or modify them. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqpp_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_bit__circuit.html">Bit_circuit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classical reversible circuit simulator.  <a href="classqpp_1_1_bit__circuit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_codes.html">Codes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that defines quantum error correcting codes  <a href="classqpp_1_1_codes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_dynamic__bitset.html">Dynamic_bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic bitset class, allows the specification of the number of bits at runtime (unlike std::bitset&lt;N&gt;)  <a href="classqpp_1_1_dynamic__bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_gates.html">Gates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that implements most commonly used gates  <a href="classqpp_1_1_gates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_i_display.html">IDisplay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class (interface) that mandates the definition of virtual std::ostream&amp; <a class="el" href="classqpp_1_1_i_display.html#ae994cbe2f2a0302dc0acc377fc3d51ab" title="Must be overridden by all derived classes. ">display(std::ostream&amp; os) const</a>.  <a href="classqpp_1_1_i_display.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_init.html">Init</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that performs additional initializations/cleanups  <a href="classqpp_1_1_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqpp_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the type is a complex type.  <a href="structqpp_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqpp_1_1is__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_complex&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the type is a complex number type, specialization for complex types.  <a href="structqpp_1_1is__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>T</em> is compatible with an STL-like iterable container.  <a href="structqpp_1_1is__iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqpp_1_1is__iterable_3_01_t_00_01to__void_3_01decltype_07std_1_1declval_3_01_t_01_4_07_08_8b9d39a7d62e9cf13651119292b7aa4db.html">is_iterable&lt; T, to_void&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()), typename T::value_type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>T</em> is compatible with an STL-like iterable container, specialization for STL-like iterable containers.  <a href="structqpp_1_1is__iterable_3_01_t_00_01to__void_3_01decltype_07std_1_1declval_3_01_t_01_4_07_08_8b9d39a7d62e9cf13651119292b7aa4db.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqpp_1_1is__matrix__expression.html">is_matrix_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the type is an Eigen matrix expression.  <a href="structqpp_1_1is__matrix__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqpp_1_1make__void.html">make_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="namespaceqpp.html#adf4dc551c8858cac37c90b561c5767cc" title="Alias template that implements the proposal for void_t. ">qpp::to_void&lt;&gt;</a> alias template.  <a href="structqpp_1_1make__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton class that manages the source of randomness in the library.  <a href="classqpp_1_1_random_devices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_states.html">States</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that implements most commonly used states  <a href="classqpp_1_1_states.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chronometer.  <a href="classqpp_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adf4dc551c8858cac37c90b561c5767cc"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:adf4dc551c8858cac37c90b561c5767cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#adf4dc551c8858cac37c90b561c5767cc">to_void</a> = typename <a class="el" href="structqpp_1_1make__void.html">make_void</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:adf4dc551c8858cac37c90b561c5767cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template that implements the proposal for void_t.  <a href="#adf4dc551c8858cac37c90b561c5767cc">More...</a><br /></td></tr>
<tr class="separator:adf4dc551c8858cac37c90b561c5767cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5f7137e8551cf82db04d3b81cdd706"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> = std::size_t</td></tr>
<tr class="memdesc:a1f5f7137e8551cf82db04d3b81cdd706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative integer index.  <a href="#a1f5f7137e8551cf82db04d3b81cdd706">More...</a><br /></td></tr>
<tr class="separator:a1f5f7137e8551cf82db04d3b81cdd706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad199ade0836f0d8488e7f6c7c8aa1949"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> = long long int</td></tr>
<tr class="memdesc:ad199ade0836f0d8488e7f6c7c8aa1949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Big integer.  <a href="#ad199ade0836f0d8488e7f6c7c8aa1949">More...</a><br /></td></tr>
<tr class="separator:ad199ade0836f0d8488e7f6c7c8aa1949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7ccc50a6b139279d7b56d07112b183"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> = std::complex&lt; double &gt;</td></tr>
<tr class="memdesc:aad7ccc50a6b139279d7b56d07112b183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in double precision.  <a href="#aad7ccc50a6b139279d7b56d07112b183">More...</a><br /></td></tr>
<tr class="separator:aad7ccc50a6b139279d7b56d07112b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7185dfc7bee58c937abc243c3692ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a> = Eigen::VectorXcd</td></tr>
<tr class="memdesc:a5d7185dfc7bee58c937abc243c3692ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen column vector.  <a href="#a5d7185dfc7bee58c937abc243c3692ea">More...</a><br /></td></tr>
<tr class="separator:a5d7185dfc7bee58c937abc243c3692ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8886624a4a55a9b45c96a623a20bf163"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8886624a4a55a9b45c96a623a20bf163">bra</a> = Eigen::RowVectorXcd</td></tr>
<tr class="memdesc:a8886624a4a55a9b45c96a623a20bf163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen row vector.  <a href="#a8886624a4a55a9b45c96a623a20bf163">More...</a><br /></td></tr>
<tr class="separator:a8886624a4a55a9b45c96a623a20bf163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de67006716bdc8fae52c6a49259276"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> = Eigen::MatrixXcd</td></tr>
<tr class="memdesc:ab0de67006716bdc8fae52c6a49259276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen matrix.  <a href="#ab0de67006716bdc8fae52c6a49259276">More...</a><br /></td></tr>
<tr class="separator:ab0de67006716bdc8fae52c6a49259276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923e2becc99eb818c04c71ae913902ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> = Eigen::MatrixXd</td></tr>
<tr class="memdesc:a923e2becc99eb818c04c71ae913902ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real (double precision) dynamic Eigen matrix.  <a href="#a923e2becc99eb818c04c71ae913902ff">More...</a><br /></td></tr>
<tr class="separator:a923e2becc99eb818c04c71ae913902ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e7c2b66f0209911cc3afc06223648"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac39e7c2b66f0209911cc3afc06223648"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:ac39e7c2b66f0209911cc3afc06223648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen matrix over the field specified by <em>Scalar</em>.  <a href="#ac39e7c2b66f0209911cc3afc06223648">More...</a><br /></td></tr>
<tr class="separator:ac39e7c2b66f0209911cc3afc06223648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c62992d1a236f062887990eea26b15"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a07c62992d1a236f062887990eea26b15"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a07c62992d1a236f062887990eea26b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen column vector over the field specified by <em>Scalar</em>.  <a href="#a07c62992d1a236f062887990eea26b15">More...</a><br /></td></tr>
<tr class="separator:a07c62992d1a236f062887990eea26b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94b7f2170b530b81ea9e1d167938589"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad94b7f2170b530b81ea9e1d167938589"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad94b7f2170b530b81ea9e1d167938589">dyn_row_vect</a> = Eigen::Matrix&lt; Scalar, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:ad94b7f2170b530b81ea9e1d167938589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen row vector over the field specified by <em>Scalar</em>.  <a href="#ad94b7f2170b530b81ea9e1d167938589">More...</a><br /></td></tr>
<tr class="separator:ad94b7f2170b530b81ea9e1d167938589"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a12e22073e741a1057129fa01b4ec10a6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a12e22073e741a1057129fa01b4ec10a6">operator&quot;&quot; _i</a> (long double x) noexcept</td></tr>
<tr class="memdesc:a12e22073e741a1057129fa01b4ec10a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_11.png"/> (real overload)  <a href="#a12e22073e741a1057129fa01b4ec10a6">More...</a><br /></td></tr>
<tr class="separator:a12e22073e741a1057129fa01b4ec10a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621afdaae12a94a5e10a874fc2073dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a621afdaae12a94a5e10a874fc2073dc0">omega</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> D)</td></tr>
<tr class="memdesc:a621afdaae12a94a5e10a874fc2073dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">D-th root of unity.  <a href="#a621afdaae12a94a5e10a874fc2073dc0">More...</a><br /></td></tr>
<tr class="separator:a621afdaae12a94a5e10a874fc2073dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a3f3073b38757ad670ad3d0c64850"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a643a3f3073b38757ad670ad3d0c64850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a643a3f3073b38757ad670ad3d0c64850">schmidtcoeffs</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a643a3f3073b38757ad670ad3d0c64850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt coefficients of the bi-partite pure state <em>A</em>.  <a href="#a643a3f3073b38757ad670ad3d0c64850">More...</a><br /></td></tr>
<tr class="separator:a643a3f3073b38757ad670ad3d0c64850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8577e76402408ffb229dd821e826a08"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac8577e76402408ffb229dd821e826a08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac8577e76402408ffb229dd821e826a08">schmidtcoeffs</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:ac8577e76402408ffb229dd821e826a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt coefficients of the bi-partite pure state <em>A</em>.  <a href="#ac8577e76402408ffb229dd821e826a08">More...</a><br /></td></tr>
<tr class="separator:ac8577e76402408ffb229dd821e826a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d0cd12502123ea1fe7c48d1043439a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a27d0cd12502123ea1fe7c48d1043439a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a27d0cd12502123ea1fe7c48d1043439a">schmidtA</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a27d0cd12502123ea1fe7c48d1043439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Alice side.  <a href="#a27d0cd12502123ea1fe7c48d1043439a">More...</a><br /></td></tr>
<tr class="separator:a27d0cd12502123ea1fe7c48d1043439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad812c56e195e8203d1be92c78837ed70"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad812c56e195e8203d1be92c78837ed70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad812c56e195e8203d1be92c78837ed70">schmidtA</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:ad812c56e195e8203d1be92c78837ed70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Alice side.  <a href="#ad812c56e195e8203d1be92c78837ed70">More...</a><br /></td></tr>
<tr class="separator:ad812c56e195e8203d1be92c78837ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9843ae59cf424139b3537d21fbfd5860"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9843ae59cf424139b3537d21fbfd5860"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9843ae59cf424139b3537d21fbfd5860">schmidtB</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a9843ae59cf424139b3537d21fbfd5860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Bob side.  <a href="#a9843ae59cf424139b3537d21fbfd5860">More...</a><br /></td></tr>
<tr class="separator:a9843ae59cf424139b3537d21fbfd5860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b86cd008bbcf7c8bc3dd1d990225fdb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3b86cd008bbcf7c8bc3dd1d990225fdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3b86cd008bbcf7c8bc3dd1d990225fdb">schmidtB</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a3b86cd008bbcf7c8bc3dd1d990225fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Bob side.  <a href="#a3b86cd008bbcf7c8bc3dd1d990225fdb">More...</a><br /></td></tr>
<tr class="separator:a3b86cd008bbcf7c8bc3dd1d990225fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ff269f163f35f9e929ca800fe8b32f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a61ff269f163f35f9e929ca800fe8b32f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a61ff269f163f35f9e929ca800fe8b32f">schmidtprobs</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a61ff269f163f35f9e929ca800fe8b32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt probabilities of the bi-partite pure state <em>A</em>.  <a href="#a61ff269f163f35f9e929ca800fe8b32f">More...</a><br /></td></tr>
<tr class="separator:a61ff269f163f35f9e929ca800fe8b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e71427121f407c51cbb0bfe0f3f0a0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a15e71427121f407c51cbb0bfe0f3f0a0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a15e71427121f407c51cbb0bfe0f3f0a0">schmidtprobs</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a15e71427121f407c51cbb0bfe0f3f0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt probabilities of the bi-partite pure state <em>A</em>.  <a href="#a15e71427121f407c51cbb0bfe0f3f0a0">More...</a><br /></td></tr>
<tr class="separator:a15e71427121f407c51cbb0bfe0f3f0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe919380a14cf18d8c845ee2e3a8f31"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9fe919380a14cf18d8c845ee2e3a8f31"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9fe919380a14cf18d8c845ee2e3a8f31">entanglement</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a9fe919380a14cf18d8c845ee2e3a8f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entanglement of the bi-partite pure state <em>A</em>.  <a href="#a9fe919380a14cf18d8c845ee2e3a8f31">More...</a><br /></td></tr>
<tr class="separator:a9fe919380a14cf18d8c845ee2e3a8f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcefa3e8c655db5fa8ff104b25082d0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2bcefa3e8c655db5fa8ff104b25082d0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2bcefa3e8c655db5fa8ff104b25082d0">entanglement</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a2bcefa3e8c655db5fa8ff104b25082d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entanglement of the bi-partite pure state <em>A</em>.  <a href="#a2bcefa3e8c655db5fa8ff104b25082d0">More...</a><br /></td></tr>
<tr class="separator:a2bcefa3e8c655db5fa8ff104b25082d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bf63d3dabba74e049aff37ea7e383"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a100bf63d3dabba74e049aff37ea7e383"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a100bf63d3dabba74e049aff37ea7e383">gconcurrence</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a100bf63d3dabba74e049aff37ea7e383"><td class="mdescLeft">&#160;</td><td class="mdescRight">G-concurrence of the bi-partite pure state <em>A</em>.  <a href="#a100bf63d3dabba74e049aff37ea7e383">More...</a><br /></td></tr>
<tr class="separator:a100bf63d3dabba74e049aff37ea7e383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e79a2383dc47a848ea3e88337070e62"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7e79a2383dc47a848ea3e88337070e62"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7e79a2383dc47a848ea3e88337070e62">negativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a7e79a2383dc47a848ea3e88337070e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negativity of the bi-partite mixed state <em>A</em>.  <a href="#a7e79a2383dc47a848ea3e88337070e62">More...</a><br /></td></tr>
<tr class="separator:a7e79a2383dc47a848ea3e88337070e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d9417d9ab61f2f78b0c4b3d8bc0674"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa5d9417d9ab61f2f78b0c4b3d8bc0674"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa5d9417d9ab61f2f78b0c4b3d8bc0674">negativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:aa5d9417d9ab61f2f78b0c4b3d8bc0674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negativity of the bi-partite mixed state <em>A</em>.  <a href="#aa5d9417d9ab61f2f78b0c4b3d8bc0674">More...</a><br /></td></tr>
<tr class="separator:aa5d9417d9ab61f2f78b0c4b3d8bc0674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825e4812d1b111b04bc3744e4abc1246"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a825e4812d1b111b04bc3744e4abc1246"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a825e4812d1b111b04bc3744e4abc1246">lognegativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a825e4812d1b111b04bc3744e4abc1246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithmic negativity of the bi-partite mixed state <em>A</em>.  <a href="#a825e4812d1b111b04bc3744e4abc1246">More...</a><br /></td></tr>
<tr class="separator:a825e4812d1b111b04bc3744e4abc1246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a907dae004630131cc42354dfd66b98"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9a907dae004630131cc42354dfd66b98"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9a907dae004630131cc42354dfd66b98">lognegativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a9a907dae004630131cc42354dfd66b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithmic negativity of the bi-partite mixed state <em>A</em>.  <a href="#a9a907dae004630131cc42354dfd66b98">More...</a><br /></td></tr>
<tr class="separator:a9a907dae004630131cc42354dfd66b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">concurrence</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wootters concurrence of the bi-partite qubit mixed state <em>A</em>.  <a href="#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">More...</a><br /></td></tr>
<tr class="separator:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922127fa0dd6659113c8277de8731c41"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a922127fa0dd6659113c8277de8731c41"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a922127fa0dd6659113c8277de8731c41">entropy</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a922127fa0dd6659113c8277de8731c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">von-Neumann entropy of the density matrix <em>A</em>  <a href="#a922127fa0dd6659113c8277de8731c41">More...</a><br /></td></tr>
<tr class="separator:a922127fa0dd6659113c8277de8731c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fd22e80ba664a4585ce87b45262efd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a11fd22e80ba664a4585ce87b45262efd">entropy</a> (const std::vector&lt; double &gt; &amp;prob)</td></tr>
<tr class="memdesc:a11fd22e80ba664a4585ce87b45262efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shannon entropy of the probability distribution <em>prob</em>.  <a href="#a11fd22e80ba664a4585ce87b45262efd">More...</a><br /></td></tr>
<tr class="separator:a11fd22e80ba664a4585ce87b45262efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991bc6df4280943452bfbedafa65b9f7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a991bc6df4280943452bfbedafa65b9f7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a991bc6df4280943452bfbedafa65b9f7">renyi</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double alpha)</td></tr>
<tr class="memdesc:a991bc6df4280943452bfbedafa65b9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renyi- <img class="formulaInl" alt="$\alpha$" src="form_17.png"/> entropy of the density matrix <em>A</em>, for <img class="formulaInl" alt="$\alpha\geq 0$" src="form_18.png"/>.  <a href="#a991bc6df4280943452bfbedafa65b9f7">More...</a><br /></td></tr>
<tr class="separator:a991bc6df4280943452bfbedafa65b9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0268f55bb9b2fdd0495d8b67f74f6e3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae0268f55bb9b2fdd0495d8b67f74f6e3">renyi</a> (const std::vector&lt; double &gt; &amp;prob, double alpha)</td></tr>
<tr class="memdesc:ae0268f55bb9b2fdd0495d8b67f74f6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renyi- <img class="formulaInl" alt="$\alpha$" src="form_17.png"/> entropy of the probability distribution <em>prob</em>, for <img class="formulaInl" alt="$\alpha\geq 0$" src="form_18.png"/>.  <a href="#ae0268f55bb9b2fdd0495d8b67f74f6e3">More...</a><br /></td></tr>
<tr class="separator:ae0268f55bb9b2fdd0495d8b67f74f6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff1197fe1e27f2dc5caeb032d80f6b4"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aeff1197fe1e27f2dc5caeb032d80f6b4"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aeff1197fe1e27f2dc5caeb032d80f6b4">tsallis</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double q)</td></tr>
<tr class="memdesc:aeff1197fe1e27f2dc5caeb032d80f6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tsallis- <img class="formulaInl" alt="$q$" src="form_21.png"/> entropy of the density matrix <em>A</em>, for <img class="formulaInl" alt="$q\geq 0$" src="form_22.png"/>.  <a href="#aeff1197fe1e27f2dc5caeb032d80f6b4">More...</a><br /></td></tr>
<tr class="separator:aeff1197fe1e27f2dc5caeb032d80f6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0439ba7f33753937fee671afe3250554"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0439ba7f33753937fee671afe3250554">tsallis</a> (const std::vector&lt; double &gt; &amp;prob, double q)</td></tr>
<tr class="memdesc:a0439ba7f33753937fee671afe3250554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tsallis- <img class="formulaInl" alt="$q$" src="form_21.png"/> entropy of the probability distribution <em>prob</em>, for <img class="formulaInl" alt="$q\geq 0$" src="form_22.png"/>.  <a href="#a0439ba7f33753937fee671afe3250554">More...</a><br /></td></tr>
<tr class="separator:a0439ba7f33753937fee671afe3250554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336521e1a561be170d44dd5a1bc81c1d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a336521e1a561be170d44dd5a1bc81c1d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a336521e1a561be170d44dd5a1bc81c1d">qmutualinfo</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsysA, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsysB, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a336521e1a561be170d44dd5a1bc81c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantum mutual information between 2 subsystems of a composite system.  <a href="#a336521e1a561be170d44dd5a1bc81c1d">More...</a><br /></td></tr>
<tr class="separator:a336521e1a561be170d44dd5a1bc81c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfb291551237e2a5b45e335141e759a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1dfb291551237e2a5b45e335141e759a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1dfb291551237e2a5b45e335141e759a">qmutualinfo</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsysA, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsysB, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a1dfb291551237e2a5b45e335141e759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantum mutual information between 2 subsystems of a composite system.  <a href="#a1dfb291551237e2a5b45e335141e759a">More...</a><br /></td></tr>
<tr class="separator:a1dfb291551237e2a5b45e335141e759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d40b2372b7537b8a5b9e0a92d729769"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2d40b2372b7537b8a5b9e0a92d729769"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2d40b2372b7537b8a5b9e0a92d729769">transpose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a2d40b2372b7537b8a5b9e0a92d729769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose.  <a href="#a2d40b2372b7537b8a5b9e0a92d729769">More...</a><br /></td></tr>
<tr class="separator:a2d40b2372b7537b8a5b9e0a92d729769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad430508f45480e4d7a8ac83ae7d00aae"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad430508f45480e4d7a8ac83ae7d00aae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad430508f45480e4d7a8ac83ae7d00aae">conjugate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:ad430508f45480e4d7a8ac83ae7d00aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate.  <a href="#ad430508f45480e4d7a8ac83ae7d00aae">More...</a><br /></td></tr>
<tr class="separator:ad430508f45480e4d7a8ac83ae7d00aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2b3538ec37539e56f77addfb9ea1dd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aba2b3538ec37539e56f77addfb9ea1dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aba2b3538ec37539e56f77addfb9ea1dd">adjoint</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:aba2b3538ec37539e56f77addfb9ea1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjoint.  <a href="#aba2b3538ec37539e56f77addfb9ea1dd">More...</a><br /></td></tr>
<tr class="separator:aba2b3538ec37539e56f77addfb9ea1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db8a845e5766ebb3f4eea5177c810de"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5db8a845e5766ebb3f4eea5177c810de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5db8a845e5766ebb3f4eea5177c810de">inverse</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a5db8a845e5766ebb3f4eea5177c810de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse.  <a href="#a5db8a845e5766ebb3f4eea5177c810de">More...</a><br /></td></tr>
<tr class="separator:a5db8a845e5766ebb3f4eea5177c810de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1daff5450728504da1fdfedf8d8b54"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1e1daff5450728504da1fdfedf8d8b54"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54">trace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a1e1daff5450728504da1fdfedf8d8b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace.  <a href="#a1e1daff5450728504da1fdfedf8d8b54">More...</a><br /></td></tr>
<tr class="separator:a1e1daff5450728504da1fdfedf8d8b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4f6e426d47b5bf66afc0f7cc0321e0eb">det</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinant.  <a href="#a4f6e426d47b5bf66afc0f7cc0321e0eb">More...</a><br /></td></tr>
<tr class="separator:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a129545b05e69dd7f4c60b009ca183"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a95a129545b05e69dd7f4c60b009ca183"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183">logdet</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a95a129545b05e69dd7f4c60b009ca183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of the determinant.  <a href="#a95a129545b05e69dd7f4c60b009ca183">More...</a><br /></td></tr>
<tr class="separator:a95a129545b05e69dd7f4c60b009ca183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a92e8a327ff86f87c6236965103797"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a48a92e8a327ff86f87c6236965103797"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a48a92e8a327ff86f87c6236965103797">sum</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a48a92e8a327ff86f87c6236965103797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of <em>A</em>.  <a href="#a48a92e8a327ff86f87c6236965103797">More...</a><br /></td></tr>
<tr class="separator:a48a92e8a327ff86f87c6236965103797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78595ec429a5df51dbe682cdb9711d9c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78595ec429a5df51dbe682cdb9711d9c"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a78595ec429a5df51dbe682cdb9711d9c">prod</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a78595ec429a5df51dbe682cdb9711d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of <em>A</em>.  <a href="#a78595ec429a5df51dbe682cdb9711d9c">More...</a><br /></td></tr>
<tr class="separator:a78595ec429a5df51dbe682cdb9711d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e4740854c958579228593dd639aa6c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af2e4740854c958579228593dd639aa6c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c">norm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:af2e4740854c958579228593dd639aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frobenius norm.  <a href="#af2e4740854c958579228593dd639aa6c">More...</a><br /></td></tr>
<tr class="separator:af2e4740854c958579228593dd639aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6eb666202bc76f713c4deadf8624a6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afa6eb666202bc76f713c4deadf8624a6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afa6eb666202bc76f713c4deadf8624a6">eig</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:afa6eb666202bc76f713c4deadf8624a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full eigen decomposition.  <a href="#afa6eb666202bc76f713c4deadf8624a6">More...</a><br /></td></tr>
<tr class="separator:afa6eb666202bc76f713c4deadf8624a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9801291f336021f67fd1a022664c24"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2f9801291f336021f67fd1a022664c24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2f9801291f336021f67fd1a022664c24">evals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a2f9801291f336021f67fd1a022664c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalues.  <a href="#a2f9801291f336021f67fd1a022664c24">More...</a><br /></td></tr>
<tr class="separator:a2f9801291f336021f67fd1a022664c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8">evects</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvectors.  <a href="#acc9597bacc39c501eb8e2e5e8530fcd8">More...</a><br /></td></tr>
<tr class="separator:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb48ecd842d8f6a3938e3e5b9a36506"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acbb48ecd842d8f6a3938e3e5b9a36506"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; double &gt;, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acbb48ecd842d8f6a3938e3e5b9a36506">heig</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:acbb48ecd842d8f6a3938e3e5b9a36506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full eigen decomposition of Hermitian expression.  <a href="#acbb48ecd842d8f6a3938e3e5b9a36506">More...</a><br /></td></tr>
<tr class="separator:acbb48ecd842d8f6a3938e3e5b9a36506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322665174fcacffbdf82dd04139d667e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a322665174fcacffbdf82dd04139d667e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a322665174fcacffbdf82dd04139d667e">hevals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a322665174fcacffbdf82dd04139d667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian eigenvalues.  <a href="#a322665174fcacffbdf82dd04139d667e">More...</a><br /></td></tr>
<tr class="separator:a322665174fcacffbdf82dd04139d667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeadaf6395c78a52339bec119c4a331b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abeadaf6395c78a52339bec119c4a331b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abeadaf6395c78a52339bec119c4a331b">hevects</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:abeadaf6395c78a52339bec119c4a331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian eigenvectors.  <a href="#abeadaf6395c78a52339bec119c4a331b">More...</a><br /></td></tr>
<tr class="separator:abeadaf6395c78a52339bec119c4a331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fbc71879953afc92d8828aa6b99627"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a01fbc71879953afc92d8828aa6b99627"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>, <a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; double &gt;, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a01fbc71879953afc92d8828aa6b99627">svd</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a01fbc71879953afc92d8828aa6b99627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full singular value decomposition.  <a href="#a01fbc71879953afc92d8828aa6b99627">More...</a><br /></td></tr>
<tr class="separator:a01fbc71879953afc92d8828aa6b99627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe012650e8ff95fc346dd75cdbb3625a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abe012650e8ff95fc346dd75cdbb3625a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abe012650e8ff95fc346dd75cdbb3625a">svals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:abe012650e8ff95fc346dd75cdbb3625a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular values.  <a href="#abe012650e8ff95fc346dd75cdbb3625a">More...</a><br /></td></tr>
<tr class="separator:abe012650e8ff95fc346dd75cdbb3625a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c070beade098fa8f26440791cc8840"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a33c070beade098fa8f26440791cc8840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a33c070beade098fa8f26440791cc8840">svdU</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a33c070beade098fa8f26440791cc8840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left singular vectors.  <a href="#a33c070beade098fa8f26440791cc8840">More...</a><br /></td></tr>
<tr class="separator:a33c070beade098fa8f26440791cc8840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a285eda1b8ec8614398dd731e5e3a89ed">svdV</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a285eda1b8ec8614398dd731e5e3a89ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right singular vectors.  <a href="#a285eda1b8ec8614398dd731e5e3a89ed">More...</a><br /></td></tr>
<tr class="separator:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b50e01fa0b26089d3944c2c56601a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a659b50e01fa0b26089d3944c2c56601a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a">funm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>(*f)(const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &amp;))</td></tr>
<tr class="memdesc:a659b50e01fa0b26089d3944c2c56601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional calculus f(A)  <a href="#a659b50e01fa0b26089d3944c2c56601a">More...</a><br /></td></tr>
<tr class="separator:a659b50e01fa0b26089d3944c2c56601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c">sqrtm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a83e2b23bc11e3cb8dd6909969af7377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix square root.  <a href="#a83e2b23bc11e3cb8dd6909969af7377c">More...</a><br /></td></tr>
<tr class="separator:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3a4cb16d97f9cc763bd133b64f2b6f6d">absm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix absolute value.  <a href="#a3a4cb16d97f9cc763bd133b64f2b6f6d">More...</a><br /></td></tr>
<tr class="separator:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6855dd77c49ae0b96baf10c12b4bc722">expm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a6855dd77c49ae0b96baf10c12b4bc722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential.  <a href="#a6855dd77c49ae0b96baf10c12b4bc722">More...</a><br /></td></tr>
<tr class="separator:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683ff6f7df206be1a6105317c4c8ed70"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a683ff6f7df206be1a6105317c4c8ed70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a683ff6f7df206be1a6105317c4c8ed70">logm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a683ff6f7df206be1a6105317c4c8ed70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix logarithm.  <a href="#a683ff6f7df206be1a6105317c4c8ed70">More...</a><br /></td></tr>
<tr class="separator:a683ff6f7df206be1a6105317c4c8ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be6e812878479d6acbd25cf5ae387c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78be6e812878479d6acbd25cf5ae387c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a78be6e812878479d6acbd25cf5ae387c">sinm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a78be6e812878479d6acbd25cf5ae387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix sin.  <a href="#a78be6e812878479d6acbd25cf5ae387c">More...</a><br /></td></tr>
<tr class="separator:a78be6e812878479d6acbd25cf5ae387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c7a2f9f27121178519ddba186fbcd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a369c7a2f9f27121178519ddba186fbcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a369c7a2f9f27121178519ddba186fbcd">cosm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a369c7a2f9f27121178519ddba186fbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix cos.  <a href="#a369c7a2f9f27121178519ddba186fbcd">More...</a><br /></td></tr>
<tr class="separator:a369c7a2f9f27121178519ddba186fbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a62d7f0db6a049f254c2a7a77af8eb29e">spectralpowm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z)</td></tr>
<tr class="memdesc:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix power.  <a href="#a62d7f0db6a049f254c2a7a77af8eb29e">More...</a><br /></td></tr>
<tr class="separator:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc34b7cd0bcbdddf99c4835489c47b5d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adc34b7cd0bcbdddf99c4835489c47b5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#adc34b7cd0bcbdddf99c4835489c47b5d">powm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> n)</td></tr>
<tr class="memdesc:adc34b7cd0bcbdddf99c4835489c47b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast matrix power based on the SQUARE-AND-MULTIPLY algorithm.  <a href="#adc34b7cd0bcbdddf99c4835489c47b5d">More...</a><br /></td></tr>
<tr class="separator:adc34b7cd0bcbdddf99c4835489c47b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1865cddc66aa88d853512abd39e584e1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1865cddc66aa88d853512abd39e584e1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1865cddc66aa88d853512abd39e584e1">schatten</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double p)</td></tr>
<tr class="memdesc:a1865cddc66aa88d853512abd39e584e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schatten matrix norm.  <a href="#a1865cddc66aa88d853512abd39e584e1">More...</a><br /></td></tr>
<tr class="separator:a1865cddc66aa88d853512abd39e584e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e336b2319f89d7817aa7979de9190f"><td class="memTemplParams" colspan="2">template&lt;typename OutputScalar , typename Derived &gt; </td></tr>
<tr class="memitem:a18e336b2319f89d7817aa7979de9190f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; OutputScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a18e336b2319f89d7817aa7979de9190f">cwise</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, OutputScalar(*f)(const typename Derived::Scalar &amp;))</td></tr>
<tr class="memdesc:a18e336b2319f89d7817aa7979de9190f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor.  <a href="#a18e336b2319f89d7817aa7979de9190f">More...</a><br /></td></tr>
<tr class="separator:a18e336b2319f89d7817aa7979de9190f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9294ebd345fe1c99731bf2b776e610d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9294ebd345fe1c99731bf2b776e610d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9294ebd345fe1c99731bf2b776e610d7">kron</a> (const T &amp;head)</td></tr>
<tr class="memdesc:a9294ebd345fe1c99731bf2b776e610d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#a9294ebd345fe1c99731bf2b776e610d7">More...</a><br /></td></tr>
<tr class="separator:a9294ebd345fe1c99731bf2b776e610d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb4e55a5b10d1cf6d638f0a92687bf5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7cb4e55a5b10d1cf6d638f0a92687bf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7cb4e55a5b10d1cf6d638f0a92687bf5">kron</a> (const T &amp;head, const Args &amp;... tail)</td></tr>
<tr class="memdesc:a7cb4e55a5b10d1cf6d638f0a92687bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#a7cb4e55a5b10d1cf6d638f0a92687bf5">More...</a><br /></td></tr>
<tr class="separator:a7cb4e55a5b10d1cf6d638f0a92687bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaceac83c64e729f98b80f72359ad7a5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afaceac83c64e729f98b80f72359ad7a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afaceac83c64e729f98b80f72359ad7a5">kron</a> (const std::vector&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:afaceac83c64e729f98b80f72359ad7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#afaceac83c64e729f98b80f72359ad7a5">More...</a><br /></td></tr>
<tr class="separator:afaceac83c64e729f98b80f72359ad7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad529abce5ec6d3b7c32ac3e9be65e577"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad529abce5ec6d3b7c32ac3e9be65e577"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad529abce5ec6d3b7c32ac3e9be65e577">kron</a> (const std::initializer_list&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:ad529abce5ec6d3b7c32ac3e9be65e577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#ad529abce5ec6d3b7c32ac3e9be65e577">More...</a><br /></td></tr>
<tr class="separator:ad529abce5ec6d3b7c32ac3e9be65e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1693a6d2628b3f3b7f69692cd8af1a9f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1693a6d2628b3f3b7f69692cd8af1a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1693a6d2628b3f3b7f69692cd8af1a9f">kronpow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> n)</td></tr>
<tr class="memdesc:a1693a6d2628b3f3b7f69692cd8af1a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker power.  <a href="#a1693a6d2628b3f3b7f69692cd8af1a9f">More...</a><br /></td></tr>
<tr class="separator:a1693a6d2628b3f3b7f69692cd8af1a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0f3ad6d1892783a265e5d373eec4a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee0f3ad6d1892783a265e5d373eec4a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aee0f3ad6d1892783a265e5d373eec4a9">dirsum</a> (const T &amp;head)</td></tr>
<tr class="memdesc:aee0f3ad6d1892783a265e5d373eec4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct sum.  <a href="#aee0f3ad6d1892783a265e5d373eec4a9">More...</a><br /></td></tr>
<tr class="separator:aee0f3ad6d1892783a265e5d373eec4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5af8a1edec21f0b70b2d17657af62a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1b5af8a1edec21f0b70b2d17657af62a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1b5af8a1edec21f0b70b2d17657af62a">dirsum</a> (const T &amp;head, const Args &amp;... tail)</td></tr>
<tr class="memdesc:a1b5af8a1edec21f0b70b2d17657af62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct sum.  <a href="#a1b5af8a1edec21f0b70b2d17657af62a">More...</a><br /></td></tr>
<tr class="separator:a1b5af8a1edec21f0b70b2d17657af62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe168752758afc9c072a852559d0733b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afe168752758afc9c072a852559d0733b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afe168752758afc9c072a852559d0733b">dirsum</a> (const std::vector&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:afe168752758afc9c072a852559d0733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct sum.  <a href="#afe168752758afc9c072a852559d0733b">More...</a><br /></td></tr>
<tr class="separator:afe168752758afc9c072a852559d0733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca56da00877956ddae60bdb12e2964ae"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aca56da00877956ddae60bdb12e2964ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aca56da00877956ddae60bdb12e2964ae">dirsum</a> (const std::initializer_list&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:aca56da00877956ddae60bdb12e2964ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct sum.  <a href="#aca56da00877956ddae60bdb12e2964ae">More...</a><br /></td></tr>
<tr class="separator:aca56da00877956ddae60bdb12e2964ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cea183ce30cc864b16a8583af6b2a6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac0cea183ce30cc864b16a8583af6b2a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac0cea183ce30cc864b16a8583af6b2a6">dirsumpow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> n)</td></tr>
<tr class="memdesc:ac0cea183ce30cc864b16a8583af6b2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct sum power.  <a href="#ac0cea183ce30cc864b16a8583af6b2a6">More...</a><br /></td></tr>
<tr class="separator:ac0cea183ce30cc864b16a8583af6b2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa33bacb26cad466156dc3f8f3980da7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afa33bacb26cad466156dc3f8f3980da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afa33bacb26cad466156dc3f8f3980da7">reshape</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols)</td></tr>
<tr class="memdesc:afa33bacb26cad466156dc3f8f3980da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape.  <a href="#afa33bacb26cad466156dc3f8f3980da7">More...</a><br /></td></tr>
<tr class="separator:afa33bacb26cad466156dc3f8f3980da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c1b998a518e655645a0285f90550e3"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:aa4c1b998a518e655645a0285f90550e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa4c1b998a518e655645a0285f90550e3">comm</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;B)</td></tr>
<tr class="memdesc:aa4c1b998a518e655645a0285f90550e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commutator.  <a href="#aa4c1b998a518e655645a0285f90550e3">More...</a><br /></td></tr>
<tr class="separator:aa4c1b998a518e655645a0285f90550e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f54909fe5801ad4bc179be28ad7a41"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:af2f54909fe5801ad4bc179be28ad7a41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af2f54909fe5801ad4bc179be28ad7a41">anticomm</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;B)</td></tr>
<tr class="memdesc:af2f54909fe5801ad4bc179be28ad7a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anti-commutator.  <a href="#af2f54909fe5801ad4bc179be28ad7a41">More...</a><br /></td></tr>
<tr class="separator:af2f54909fe5801ad4bc179be28ad7a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b51403e1cb33d8c1f7678eb8aae42c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a13b51403e1cb33d8c1f7678eb8aae42c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a13b51403e1cb33d8c1f7678eb8aae42c">prj</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a13b51403e1cb33d8c1f7678eb8aae42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector.  <a href="#a13b51403e1cb33d8c1f7678eb8aae42c">More...</a><br /></td></tr>
<tr class="separator:a13b51403e1cb33d8c1f7678eb8aae42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd864d5b7c0edfe047589282d701950"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9bd864d5b7c0edfe047589282d701950"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9bd864d5b7c0edfe047589282d701950">grams</a> (const std::vector&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:a9bd864d5b7c0edfe047589282d701950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization.  <a href="#a9bd864d5b7c0edfe047589282d701950">More...</a><br /></td></tr>
<tr class="separator:a9bd864d5b7c0edfe047589282d701950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40f14c3ec60bace8ab14a733d161932"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae40f14c3ec60bace8ab14a733d161932"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae40f14c3ec60bace8ab14a733d161932">grams</a> (const std::initializer_list&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:ae40f14c3ec60bace8ab14a733d161932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization.  <a href="#ae40f14c3ec60bace8ab14a733d161932">More...</a><br /></td></tr>
<tr class="separator:ae40f14c3ec60bace8ab14a733d161932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4917f28299b0430203972045b8cf377"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa4917f28299b0430203972045b8cf377"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa4917f28299b0430203972045b8cf377">grams</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:aa4917f28299b0430203972045b8cf377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization.  <a href="#aa4917f28299b0430203972045b8cf377">More...</a><br /></td></tr>
<tr class="separator:aa4917f28299b0430203972045b8cf377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6a9fc4e463ff3397ced98bc9df0a1c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5c6a9fc4e463ff3397ced98bc9df0a1c">n2multiidx</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> n, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a5c6a9fc4e463ff3397ced98bc9df0a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative integer index to multi-index.  <a href="#a5c6a9fc4e463ff3397ced98bc9df0a1c">More...</a><br /></td></tr>
<tr class="separator:a5c6a9fc4e463ff3397ced98bc9df0a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ce02aa3e299e610cf5f7715c1a43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9f0ce02aa3e299e610cf5f7715c1a43f">multiidx2n</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;midx, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a9f0ce02aa3e299e610cf5f7715c1a43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-index to non-negative integer index.  <a href="#a9f0ce02aa3e299e610cf5f7715c1a43f">More...</a><br /></td></tr>
<tr class="separator:a9f0ce02aa3e299e610cf5f7715c1a43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f09ed5c440772b552a289b800d4415a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2f09ed5c440772b552a289b800d4415a">mket</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;mask, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a2f09ed5c440772b552a289b800d4415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-partite qudit ket.  <a href="#a2f09ed5c440772b552a289b800d4415a">More...</a><br /></td></tr>
<tr class="separator:a2f09ed5c440772b552a289b800d4415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d054252433fbf793575092697f9d985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3d054252433fbf793575092697f9d985">mket</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;mask, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a3d054252433fbf793575092697f9d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-partite qudit ket.  <a href="#a3d054252433fbf793575092697f9d985">More...</a><br /></td></tr>
<tr class="separator:a3d054252433fbf793575092697f9d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee4bf8befeea8079ad61c7070ba9fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3ee4bf8befeea8079ad61c7070ba9fa2">mprj</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;mask, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a3ee4bf8befeea8079ad61c7070ba9fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector onto multi-partite qudit ket.  <a href="#a3ee4bf8befeea8079ad61c7070ba9fa2">More...</a><br /></td></tr>
<tr class="separator:a3ee4bf8befeea8079ad61c7070ba9fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4e06590399ad3a7b4a15ba62849e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7a4e06590399ad3a7b4a15ba62849e82">mprj</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;mask, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a7a4e06590399ad3a7b4a15ba62849e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector onto multi-partite qudit ket.  <a href="#a7a4e06590399ad3a7b4a15ba62849e82">More...</a><br /></td></tr>
<tr class="separator:a7a4e06590399ad3a7b4a15ba62849e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9825a190c56286a68989b67620bbb9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a3e9825a190c56286a68989b67620bbb9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3e9825a190c56286a68989b67620bbb9">abssq</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a3e9825a190c56286a68989b67620bbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute values squared of an STL-like range of complex numbers.  <a href="#a3e9825a190c56286a68989b67620bbb9">More...</a><br /></td></tr>
<tr class="separator:a3e9825a190c56286a68989b67620bbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fc4d84b7de3be27d575d823611ed08"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a31fc4d84b7de3be27d575d823611ed08"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a31fc4d84b7de3be27d575d823611ed08">abssq</a> (const Container &amp;c, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a31fc4d84b7de3be27d575d823611ed08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute values squared of an STL-like container.  <a href="#a31fc4d84b7de3be27d575d823611ed08">More...</a><br /></td></tr>
<tr class="separator:a31fc4d84b7de3be27d575d823611ed08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07276990fbab7f30c1e9ad0a339e5215"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a07276990fbab7f30c1e9ad0a339e5215"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a07276990fbab7f30c1e9ad0a339e5215">abssq</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a07276990fbab7f30c1e9ad0a339e5215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute values squared of an Eigen expression.  <a href="#a07276990fbab7f30c1e9ad0a339e5215">More...</a><br /></td></tr>
<tr class="separator:a07276990fbab7f30c1e9ad0a339e5215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fdacbcc8284b5088c582310f9962f1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a71fdacbcc8284b5088c582310f9962f1"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; InputIterator &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a71fdacbcc8284b5088c582310f9962f1">sum</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a71fdacbcc8284b5088c582310f9962f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of an STL-like range.  <a href="#a71fdacbcc8284b5088c582310f9962f1">More...</a><br /></td></tr>
<tr class="separator:a71fdacbcc8284b5088c582310f9962f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126bc1c914bda6a04c1c622cddb8afe"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a1126bc1c914bda6a04c1c622cddb8afe"><td class="memTemplItemLeft" align="right" valign="top">Container::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1126bc1c914bda6a04c1c622cddb8afe">sum</a> (const Container &amp;c, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a1126bc1c914bda6a04c1c622cddb8afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of the elements of an STL-like container.  <a href="#a1126bc1c914bda6a04c1c622cddb8afe">More...</a><br /></td></tr>
<tr class="separator:a1126bc1c914bda6a04c1c622cddb8afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4d7011145e0589b6ba5767dcf90885"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a7f4d7011145e0589b6ba5767dcf90885"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; InputIterator &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7f4d7011145e0589b6ba5767dcf90885">prod</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a7f4d7011145e0589b6ba5767dcf90885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of an STL-like range.  <a href="#a7f4d7011145e0589b6ba5767dcf90885">More...</a><br /></td></tr>
<tr class="separator:a7f4d7011145e0589b6ba5767dcf90885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e14900b6eb348ef350c455f1110327"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aa4e14900b6eb348ef350c455f1110327"><td class="memTemplItemLeft" align="right" valign="top">Container::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa4e14900b6eb348ef350c455f1110327">prod</a> (const Container &amp;c, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:aa4e14900b6eb348ef350c455f1110327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of the elements of an STL-like container.  <a href="#aa4e14900b6eb348ef350c455f1110327">More...</a><br /></td></tr>
<tr class="separator:aa4e14900b6eb348ef350c455f1110327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0046735db751418aea0b81d0cb048"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad3b0046735db751418aea0b81d0cb048"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad3b0046735db751418aea0b81d0cb048">rho2pure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:ad3b0046735db751418aea0b81d0cb048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the pure state representation of a matrix proportional to a projector onto a pure state.  <a href="#ad3b0046735db751418aea0b81d0cb048">More...</a><br /></td></tr>
<tr class="separator:ad3b0046735db751418aea0b81d0cb048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ad5b3e58dedde05467ac1961e44892"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87ad5b3e58dedde05467ac1961e44892"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a87ad5b3e58dedde05467ac1961e44892">complement</a> (std::vector&lt; T &gt; subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N)</td></tr>
<tr class="memdesc:a87ad5b3e58dedde05467ac1961e44892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the complement of a subsystem vector.  <a href="#a87ad5b3e58dedde05467ac1961e44892">More...</a><br /></td></tr>
<tr class="separator:a87ad5b3e58dedde05467ac1961e44892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8b1ec9320981f9b5d6984810f14737"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2b8b1ec9320981f9b5d6984810f14737"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2b8b1ec9320981f9b5d6984810f14737">rho2bloch</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a2b8b1ec9320981f9b5d6984810f14737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the 3-dimensional real Bloch vector corresponding to the qubit density matrix <em>A</em>.  <a href="#a2b8b1ec9320981f9b5d6984810f14737">More...</a><br /></td></tr>
<tr class="separator:a2b8b1ec9320981f9b5d6984810f14737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5c413d74d838e78264444307e81576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7e5c413d74d838e78264444307e81576">bloch2rho</a> (const std::vector&lt; double &gt; &amp;r)</td></tr>
<tr class="memdesc:a7e5c413d74d838e78264444307e81576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the density matrix corresponding to the 3-dimensional real Bloch vector <em>r</em>.  <a href="#a7e5c413d74d838e78264444307e81576">More...</a><br /></td></tr>
<tr class="separator:a7e5c413d74d838e78264444307e81576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1805e175751ef749374e3c8499f15d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4f1805e175751ef749374e3c8499f15d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d">disp</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a>=<a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a>)</td></tr>
<tr class="memdesc:a4f1805e175751ef749374e3c8499f15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen expression ostream manipulator.  <a href="#a4f1805e175751ef749374e3c8499f15d">More...</a><br /></td></tr>
<tr class="separator:a4f1805e175751ef749374e3c8499f15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a815b8e5cf5cd3ab4c463bf53eb550dbf">disp</a> (<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z, double <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a>=<a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a>)</td></tr>
<tr class="memdesc:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number ostream manipulator.  <a href="#a815b8e5cf5cd3ab4c463bf53eb550dbf">More...</a><br /></td></tr>
<tr class="separator:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc152d12deb461b1a0b1d8eac7c9815"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a7cc152d12deb461b1a0b1d8eac7c9815"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt; InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7cc152d12deb461b1a0b1d8eac7c9815">disp</a> (InputIterator first, InputIterator last, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:a7cc152d12deb461b1a0b1d8eac7c9815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range ostream manipulator.  <a href="#a7cc152d12deb461b1a0b1d8eac7c9815">More...</a><br /></td></tr>
<tr class="separator:a7cc152d12deb461b1a0b1d8eac7c9815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511ed948dfcfc43535412d9cc9a586a6"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a511ed948dfcfc43535412d9cc9a586a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt; typename Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a511ed948dfcfc43535412d9cc9a586a6">disp</a> (const Container &amp;c, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a511ed948dfcfc43535412d9cc9a586a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard container ostream manipulator. The container must support std::begin(), std::end() and forward iteration.  <a href="#a511ed948dfcfc43535412d9cc9a586a6">More...</a><br /></td></tr>
<tr class="separator:a511ed948dfcfc43535412d9cc9a586a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a947f46b0a59a26de227e1c4d786b9"><td class="memTemplParams" colspan="2">template&lt;typename PointerType &gt; </td></tr>
<tr class="memitem:ad7a947f46b0a59a26de227e1c4d786b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">internal::IOManipPointer</a>&lt; PointerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad7a947f46b0a59a26de227e1c4d786b9">disp</a> (const PointerType *p, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:ad7a947f46b0a59a26de227e1c4d786b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style pointer ostream manipulator.  <a href="#ad7a947f46b0a59a26de227e1c4d786b9">More...</a><br /></td></tr>
<tr class="separator:ad7a947f46b0a59a26de227e1c4d786b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238cf516513837235fbc7d7d283f7b78"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a238cf516513837235fbc7d7d283f7b78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a238cf516513837235fbc7d7d283f7b78">save</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;fname)</td></tr>
<tr class="memdesc:a238cf516513837235fbc7d7d283f7b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves Eigen expression to a binary file (internal format) in double precision.  <a href="#a238cf516513837235fbc7d7d283f7b78">More...</a><br /></td></tr>
<tr class="separator:a238cf516513837235fbc7d7d283f7b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b39f40a9c9a188a5e0dd244b4bf08"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aea6b39f40a9c9a188a5e0dd244b4bf08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aea6b39f40a9c9a188a5e0dd244b4bf08">load</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:aea6b39f40a9c9a188a5e0dd244b4bf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Eigen matrix from a binary file (internal format) in double precision.  <a href="#aea6b39f40a9c9a188a5e0dd244b4bf08">More...</a><br /></td></tr>
<tr class="separator:aea6b39f40a9c9a188a5e0dd244b4bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e5b57c3236108d853fd3b83d64a20"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a484e5b57c3236108d853fd3b83d64a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a484e5b57c3236108d853fd3b83d64a20">ip</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;phi, const Eigen::MatrixBase&lt; Derived &gt; &amp;psi, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a484e5b57c3236108d853fd3b83d64a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized inner product.  <a href="#a484e5b57c3236108d853fd3b83d64a20">More...</a><br /></td></tr>
<tr class="separator:a484e5b57c3236108d853fd3b83d64a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aa9dc2db88b74196c4ea59c2c2ff97"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a09aa9dc2db88b74196c4ea59c2c2ff97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a09aa9dc2db88b74196c4ea59c2c2ff97">ip</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;phi, const Eigen::MatrixBase&lt; Derived &gt; &amp;psi, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a09aa9dc2db88b74196c4ea59c2c2ff97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized inner product.  <a href="#a09aa9dc2db88b74196c4ea59c2c2ff97">More...</a><br /></td></tr>
<tr class="separator:a09aa9dc2db88b74196c4ea59c2c2ff97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65da96cadec88fbbb3cc70b0a82fa90c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a65da96cadec88fbbb3cc70b0a82fa90c"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a65da96cadec88fbbb3cc70b0a82fa90c">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a65da96cadec88fbbb3cc70b0a82fa90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a65da96cadec88fbbb3cc70b0a82fa90c">More...</a><br /></td></tr>
<tr class="separator:a65da96cadec88fbbb3cc70b0a82fa90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943b1da665384d3076f7118771783e84"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a943b1da665384d3076f7118771783e84"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a943b1da665384d3076f7118771783e84">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a943b1da665384d3076f7118771783e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a943b1da665384d3076f7118771783e84">More...</a><br /></td></tr>
<tr class="separator:a943b1da665384d3076f7118771783e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb1c411953ecda5ed943c7afec47c4"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0dcb1c411953ecda5ed943c7afec47c4"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0dcb1c411953ecda5ed943c7afec47c4">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;U)</td></tr>
<tr class="memdesc:a0dcb1c411953ecda5ed943c7afec47c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>.  <a href="#a0dcb1c411953ecda5ed943c7afec47c4">More...</a><br /></td></tr>
<tr class="separator:a0dcb1c411953ecda5ed943c7afec47c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc560cc8d11fa4464bc0872e167b6ef3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afc560cc8d11fa4464bc0872e167b6ef3"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afc560cc8d11fa4464bc0872e167b6ef3">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:afc560cc8d11fa4464bc0872e167b6ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#afc560cc8d11fa4464bc0872e167b6ef3">More...</a><br /></td></tr>
<tr class="separator:afc560cc8d11fa4464bc0872e167b6ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b026b0c869a4b789f25e82062ecf875"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3b026b0c869a4b789f25e82062ecf875"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3b026b0c869a4b789f25e82062ecf875">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a3b026b0c869a4b789f25e82062ecf875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a3b026b0c869a4b789f25e82062ecf875">More...</a><br /></td></tr>
<tr class="separator:a3b026b0c869a4b789f25e82062ecf875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae883fc70a9e90e3a2d3e55bd79afdc"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5ae883fc70a9e90e3a2d3e55bd79afdc"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5ae883fc70a9e90e3a2d3e55bd79afdc">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a5ae883fc70a9e90e3a2d3e55bd79afdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a5ae883fc70a9e90e3a2d3e55bd79afdc">More...</a><br /></td></tr>
<tr class="separator:a5ae883fc70a9e90e3a2d3e55bd79afdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10244fe2afb77153b3a1d33e5bd3576a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a10244fe2afb77153b3a1d33e5bd3576a"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a10244fe2afb77153b3a1d33e5bd3576a">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a10244fe2afb77153b3a1d33e5bd3576a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a10244fe2afb77153b3a1d33e5bd3576a">More...</a><br /></td></tr>
<tr class="separator:a10244fe2afb77153b3a1d33e5bd3576a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa693d26c5d066161a0dbf66f6ebb711"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aaa693d26c5d066161a0dbf66f6ebb711"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aaa693d26c5d066161a0dbf66f6ebb711">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;V, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:aaa693d26c5d066161a0dbf66f6ebb711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the orthonormal basis or rank-1 POVM specified by the matrix <em>V</em>.  <a href="#aaa693d26c5d066161a0dbf66f6ebb711">More...</a><br /></td></tr>
<tr class="separator:aaa693d26c5d066161a0dbf66f6ebb711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c01499b1db74022e6f4d8d5e730f800"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9c01499b1db74022e6f4d8d5e730f800"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt; double &gt;, std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9c01499b1db74022e6f4d8d5e730f800">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;V, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a9c01499b1db74022e6f4d8d5e730f800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the orthonormal basis or rank-1 POVM specified by the matrix <em>V</em>.  <a href="#a9c01499b1db74022e6f4d8d5e730f800">More...</a><br /></td></tr>
<tr class="separator:a9c01499b1db74022e6f4d8d5e730f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa711cc3f139002a0954b612a57409651"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa711cc3f139002a0954b612a57409651"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;, double, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651">measure_seq</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; subsys, std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; dims)</td></tr>
<tr class="memdesc:aa711cc3f139002a0954b612a57409651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the computational basis.  <a href="#aa711cc3f139002a0954b612a57409651">More...</a><br /></td></tr>
<tr class="separator:aa711cc3f139002a0954b612a57409651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fc09ba403372739d5a1f6105ef973f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a49fc09ba403372739d5a1f6105ef973f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;, double, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a49fc09ba403372739d5a1f6105ef973f">measure_seq</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a49fc09ba403372739d5a1f6105ef973f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the computational basis.  <a href="#a49fc09ba403372739d5a1f6105ef973f">More...</a><br /></td></tr>
<tr class="separator:a49fc09ba403372739d5a1f6105ef973f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624018095ea24ab31e6a9d93c33b3aa2"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a624018095ea24ab31e6a9d93c33b3aa2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;::value, <a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a624018095ea24ab31e6a9d93c33b3aa2">loadMATLAB</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:a624018095ea24ab31e6a9d93c33b3aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a complex Eigen dynamic matrix from a MATLAB .mat file,.  <a href="#a624018095ea24ab31e6a9d93c33b3aa2">More...</a><br /></td></tr>
<tr class="separator:a624018095ea24ab31e6a9d93c33b3aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ebc145afb868fcb89b3e2f98e808b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af46ebc145afb868fcb89b3e2f98e808b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;::value, <a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af46ebc145afb868fcb89b3e2f98e808b">loadMATLAB</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:af46ebc145afb868fcb89b3e2f98e808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a non-complex Eigen dynamic matrix from a MATLAB .mat file,.  <a href="#af46ebc145afb868fcb89b3e2f98e808b">More...</a><br /></td></tr>
<tr class="separator:af46ebc145afb868fcb89b3e2f98e808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dfa25e02fa2c9939cfeb828f76f86e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a37dfa25e02fa2c9939cfeb828f76f86e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37dfa25e02fa2c9939cfeb828f76f86e">saveMATLAB</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a37dfa25e02fa2c9939cfeb828f76f86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a complex Eigen dynamic matrix to a MATLAB .mat file,.  <a href="#a37dfa25e02fa2c9939cfeb828f76f86e">More...</a><br /></td></tr>
<tr class="separator:a37dfa25e02fa2c9939cfeb828f76f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d15195b80026f19f9f72fdead71d3f5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7d15195b80026f19f9f72fdead71d3f5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7d15195b80026f19f9f72fdead71d3f5">saveMATLAB</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a7d15195b80026f19f9f72fdead71d3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a non-complex Eigen dynamic matrix to a MATLAB .mat file,.  <a href="#a7d15195b80026f19f9f72fdead71d3f5">More...</a><br /></td></tr>
<tr class="separator:a7d15195b80026f19f9f72fdead71d3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6723d802f5d4c15f0d14fa1abee7bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ace6723d802f5d4c15f0d14fa1abee7bb">x2contfrac</a> (double x, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cut=1e5)</td></tr>
<tr class="memdesc:ace6723d802f5d4c15f0d14fa1abee7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple continued fraction expansion.  <a href="#ace6723d802f5d4c15f0d14fa1abee7bb">More...</a><br /></td></tr>
<tr class="separator:ace6723d802f5d4c15f0d14fa1abee7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f4dd20b7c8cdd7d07c596e5b83ee2e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a33f4dd20b7c8cdd7d07c596e5b83ee2e">contfrac2x</a> (const std::vector&lt; int &gt; &amp;cf, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N=<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>(-1))</td></tr>
<tr class="memdesc:a33f4dd20b7c8cdd7d07c596e5b83ee2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real representation of a simple continued fraction.  <a href="#a33f4dd20b7c8cdd7d07c596e5b83ee2e">More...</a><br /></td></tr>
<tr class="separator:a33f4dd20b7c8cdd7d07c596e5b83ee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f32c6f38bc3b174ee257b26c7750a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a51f32c6f38bc3b174ee257b26c7750a2">gcd</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> b)</td></tr>
<tr class="memdesc:a51f32c6f38bc3b174ee257b26c7750a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor of two integers.  <a href="#a51f32c6f38bc3b174ee257b26c7750a2">More...</a><br /></td></tr>
<tr class="separator:a51f32c6f38bc3b174ee257b26c7750a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30154e60ca47ab955ac06b5a31360f2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a30154e60ca47ab955ac06b5a31360f2a">gcd</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> &gt; &amp;as)</td></tr>
<tr class="memdesc:a30154e60ca47ab955ac06b5a31360f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor of a list of integers.  <a href="#a30154e60ca47ab955ac06b5a31360f2a">More...</a><br /></td></tr>
<tr class="separator:a30154e60ca47ab955ac06b5a31360f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aee2554ea53f80d42b6b50ab9bca2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a88aee2554ea53f80d42b6b50ab9bca2c">lcm</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> b)</td></tr>
<tr class="memdesc:a88aee2554ea53f80d42b6b50ab9bca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple of two integers.  <a href="#a88aee2554ea53f80d42b6b50ab9bca2c">More...</a><br /></td></tr>
<tr class="separator:a88aee2554ea53f80d42b6b50ab9bca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af9ed6900ebdce2f6cc5b04047d6b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9af9ed6900ebdce2f6cc5b04047d6b67">lcm</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> &gt; &amp;as)</td></tr>
<tr class="memdesc:a9af9ed6900ebdce2f6cc5b04047d6b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple of a list of integers.  <a href="#a9af9ed6900ebdce2f6cc5b04047d6b67">More...</a><br /></td></tr>
<tr class="separator:a9af9ed6900ebdce2f6cc5b04047d6b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e880587519c2861caf0bcdfb219a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a396e880587519c2861caf0bcdfb219a0">invperm</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;perm)</td></tr>
<tr class="memdesc:a396e880587519c2861caf0bcdfb219a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation.  <a href="#a396e880587519c2861caf0bcdfb219a0">More...</a><br /></td></tr>
<tr class="separator:a396e880587519c2861caf0bcdfb219a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0cdf917f1a5e398e9978fb36141a27"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9a0cdf917f1a5e398e9978fb36141a27">compperm</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;perm, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;<a class="el" href="namespaceqpp.html#a5dac002761cbcfb72cdb6a573e2689c3">sigma</a>)</td></tr>
<tr class="memdesc:a9a0cdf917f1a5e398e9978fb36141a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose permutations.  <a href="#a9a0cdf917f1a5e398e9978fb36141a27">More...</a><br /></td></tr>
<tr class="separator:a9a0cdf917f1a5e398e9978fb36141a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048622e398319b61f9ea62a6c66e67fb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a048622e398319b61f9ea62a6c66e67fb">factors</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a)</td></tr>
<tr class="memdesc:a048622e398319b61f9ea62a6c66e67fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime factor decomposition.  <a href="#a048622e398319b61f9ea62a6c66e67fb">More...</a><br /></td></tr>
<tr class="separator:a048622e398319b61f9ea62a6c66e67fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc15bf57e2a45f720b0f49034c22827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#affc15bf57e2a45f720b0f49034c22827">modmul</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> b, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> p)</td></tr>
<tr class="memdesc:affc15bf57e2a45f720b0f49034c22827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modular multiplication without overflow.  <a href="#affc15bf57e2a45f720b0f49034c22827">More...</a><br /></td></tr>
<tr class="separator:affc15bf57e2a45f720b0f49034c22827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff25c25c0ff9304255495eb90b98d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0ff25c25c0ff9304255495eb90b98d1b">modpow</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> n, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> p)</td></tr>
<tr class="memdesc:a0ff25c25c0ff9304255495eb90b98d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast integer power modulo <em>p</em> based on the SQUARE-AND-MULTIPLY algorithm.  <a href="#a0ff25c25c0ff9304255495eb90b98d1b">More...</a><br /></td></tr>
<tr class="separator:a0ff25c25c0ff9304255495eb90b98d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d115963145ca884c5d9ef8f3b18bf83"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0d115963145ca884c5d9ef8f3b18bf83">egcd</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> b)</td></tr>
<tr class="memdesc:a0d115963145ca884c5d9ef8f3b18bf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended greatest common divisor of two integers.  <a href="#a0d115963145ca884c5d9ef8f3b18bf83">More...</a><br /></td></tr>
<tr class="separator:a0d115963145ca884c5d9ef8f3b18bf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e53beed2f6bb8d374ac2e2460aee2c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7e53beed2f6bb8d374ac2e2460aee2c2">modinv</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> p)</td></tr>
<tr class="memdesc:a7e53beed2f6bb8d374ac2e2460aee2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modular inverse of <em>a</em> mod <em>p</em>.  <a href="#a7e53beed2f6bb8d374ac2e2460aee2c2">More...</a><br /></td></tr>
<tr class="separator:a7e53beed2f6bb8d374ac2e2460aee2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d77d87a676a0b2a04bceeef275aa12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa2d77d87a676a0b2a04bceeef275aa12">isprime</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> p, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> k=80)</td></tr>
<tr class="memdesc:aa2d77d87a676a0b2a04bceeef275aa12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primality test based on the Miller-Rabin's algorithm.  <a href="#aa2d77d87a676a0b2a04bceeef275aa12">More...</a><br /></td></tr>
<tr class="separator:aa2d77d87a676a0b2a04bceeef275aa12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a4e9b856bf9a858b71c536acbbab39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac7a4e9b856bf9a858b71c536acbbab39">randprime</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> b, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N=1000)</td></tr>
<tr class="memdesc:ac7a4e9b856bf9a858b71c536acbbab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random big prime uniformly distributed in the interval [a, b].  <a href="#ac7a4e9b856bf9a858b71c536acbbab39">More...</a><br /></td></tr>
<tr class="separator:ac7a4e9b856bf9a858b71c536acbbab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e583ad0b10c1250e39c9d9bc8bade78"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1e583ad0b10c1250e39c9d9bc8bade78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1e583ad0b10c1250e39c9d9bc8bade78">applyCTRL</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;ctrl, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a1e583ad0b10c1250e39c9d9bc8bade78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a1e583ad0b10c1250e39c9d9bc8bade78">More...</a><br /></td></tr>
<tr class="separator:a1e583ad0b10c1250e39c9d9bc8bade78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3fc9e33a8a12fe082359b2b86bf504"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a3c3fc9e33a8a12fe082359b2b86bf504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3c3fc9e33a8a12fe082359b2b86bf504">applyCTRL</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;ctrl, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a3c3fc9e33a8a12fe082359b2b86bf504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a3c3fc9e33a8a12fe082359b2b86bf504">More...</a><br /></td></tr>
<tr class="separator:a3c3fc9e33a8a12fe082359b2b86bf504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc60c95fa5b4158e153269699d245bc"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a6cc60c95fa5b4158e153269699d245bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6cc60c95fa5b4158e153269699d245bc">apply</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a6cc60c95fa5b4158e153269699d245bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a6cc60c95fa5b4158e153269699d245bc">More...</a><br /></td></tr>
<tr class="separator:a6cc60c95fa5b4158e153269699d245bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b0262b2151f6e37a7e86ca8213597f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a08b0262b2151f6e37a7e86ca8213597f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a08b0262b2151f6e37a7e86ca8213597f">apply</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a08b0262b2151f6e37a7e86ca8213597f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a08b0262b2151f6e37a7e86ca8213597f">More...</a><br /></td></tr>
<tr class="separator:a08b0262b2151f6e37a7e86ca8213597f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b7bce27da056e972cc75aa7473e36"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1b9b7bce27da056e972cc75aa7473e36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1b9b7bce27da056e972cc75aa7473e36">apply</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a1b9b7bce27da056e972cc75aa7473e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the density matrix <em>A</em>.  <a href="#a1b9b7bce27da056e972cc75aa7473e36">More...</a><br /></td></tr>
<tr class="separator:a1b9b7bce27da056e972cc75aa7473e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4795b6b4ac7a790a6e5197c9bfb3080a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4795b6b4ac7a790a6e5197c9bfb3080a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4795b6b4ac7a790a6e5197c9bfb3080a">apply</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a4795b6b4ac7a790a6e5197c9bfb3080a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>A</em>.  <a href="#a4795b6b4ac7a790a6e5197c9bfb3080a">More...</a><br /></td></tr>
<tr class="separator:a4795b6b4ac7a790a6e5197c9bfb3080a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef6d510aeae580845ba98e8c8ecfa58"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8ef6d510aeae580845ba98e8c8ecfa58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8ef6d510aeae580845ba98e8c8ecfa58">apply</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a8ef6d510aeae580845ba98e8c8ecfa58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>A</em>.  <a href="#a8ef6d510aeae580845ba98e8c8ecfa58">More...</a><br /></td></tr>
<tr class="separator:a8ef6d510aeae580845ba98e8c8ecfa58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474d2e8fdbac3fb577c835e5416fecaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a474d2e8fdbac3fb577c835e5416fecaa">kraus2super</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a474d2e8fdbac3fb577c835e5416fecaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superoperator matrix.  <a href="#a474d2e8fdbac3fb577c835e5416fecaa">More...</a><br /></td></tr>
<tr class="separator:a474d2e8fdbac3fb577c835e5416fecaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f23aa8ee0eb007532b29ada39091d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9f23aa8ee0eb007532b29ada39091d4f">kraus2choi</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a9f23aa8ee0eb007532b29ada39091d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choi matrix.  <a href="#a9f23aa8ee0eb007532b29ada39091d4f">More...</a><br /></td></tr>
<tr class="separator:a9f23aa8ee0eb007532b29ada39091d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08330f1578fa6b6e382a80132dffb46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac08330f1578fa6b6e382a80132dffb46">choi2kraus</a> (const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;A)</td></tr>
<tr class="memdesc:ac08330f1578fa6b6e382a80132dffb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonal Kraus operators from Choi matrix.  <a href="#ac08330f1578fa6b6e382a80132dffb46">More...</a><br /></td></tr>
<tr class="separator:ac08330f1578fa6b6e382a80132dffb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5fb595977b62ea764f9362828678f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8b5fb595977b62ea764f9362828678f2">choi2super</a> (const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;A)</td></tr>
<tr class="memdesc:a8b5fb595977b62ea764f9362828678f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Choi matrix to superoperator matrix.  <a href="#a8b5fb595977b62ea764f9362828678f2">More...</a><br /></td></tr>
<tr class="separator:a8b5fb595977b62ea764f9362828678f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b8ee9e2f9b51a281f7c42f61571c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad2b8ee9e2f9b51a281f7c42f61571c9a">super2choi</a> (const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;A)</td></tr>
<tr class="memdesc:ad2b8ee9e2f9b51a281f7c42f61571c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts superoperator matrix to Choi matrix.  <a href="#ad2b8ee9e2f9b51a281f7c42f61571c9a">More...</a><br /></td></tr>
<tr class="separator:ad2b8ee9e2f9b51a281f7c42f61571c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1f6add4257e7a92af4378a848110b7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3e1f6add4257e7a92af4378a848110b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3e1f6add4257e7a92af4378a848110b7">ptrace1</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a3e1f6add4257e7a92af4378a848110b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a3e1f6add4257e7a92af4378a848110b7">More...</a><br /></td></tr>
<tr class="separator:a3e1f6add4257e7a92af4378a848110b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435a02748cdfe4077d12cb743b0a3cd1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a435a02748cdfe4077d12cb743b0a3cd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a435a02748cdfe4077d12cb743b0a3cd1">ptrace1</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a435a02748cdfe4077d12cb743b0a3cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a435a02748cdfe4077d12cb743b0a3cd1">More...</a><br /></td></tr>
<tr class="separator:a435a02748cdfe4077d12cb743b0a3cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0652daea1cfc2385239956ca80b356"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9c0652daea1cfc2385239956ca80b356"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9c0652daea1cfc2385239956ca80b356">ptrace2</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a9c0652daea1cfc2385239956ca80b356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a9c0652daea1cfc2385239956ca80b356">More...</a><br /></td></tr>
<tr class="separator:a9c0652daea1cfc2385239956ca80b356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59c0f704c3fde8bb8c4fae5cd3cce7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0e59c0f704c3fde8bb8c4fae5cd3cce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0e59c0f704c3fde8bb8c4fae5cd3cce7">ptrace2</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:a0e59c0f704c3fde8bb8c4fae5cd3cce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a0e59c0f704c3fde8bb8c4fae5cd3cce7">More...</a><br /></td></tr>
<tr class="separator:a0e59c0f704c3fde8bb8c4fae5cd3cce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300526d686af7fec966d8760087a168"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1300526d686af7fec966d8760087a168"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1300526d686af7fec966d8760087a168">ptrace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a1300526d686af7fec966d8760087a168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a1300526d686af7fec966d8760087a168">More...</a><br /></td></tr>
<tr class="separator:a1300526d686af7fec966d8760087a168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30f9afcc0a3a5bacb04cb2a8a675743"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ab30f9afcc0a3a5bacb04cb2a8a675743"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab30f9afcc0a3a5bacb04cb2a8a675743">ptrace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:ab30f9afcc0a3a5bacb04cb2a8a675743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#ab30f9afcc0a3a5bacb04cb2a8a675743">More...</a><br /></td></tr>
<tr class="separator:ab30f9afcc0a3a5bacb04cb2a8a675743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eda566cbbf3baaf8d897d5d49fb5f1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a97eda566cbbf3baaf8d897d5d49fb5f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a97eda566cbbf3baaf8d897d5d49fb5f1">ptranspose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a97eda566cbbf3baaf8d897d5d49fb5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial transpose.  <a href="#a97eda566cbbf3baaf8d897d5d49fb5f1">More...</a><br /></td></tr>
<tr class="separator:a97eda566cbbf3baaf8d897d5d49fb5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa62e91772d192f1a7981f651ff9072c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aaa62e91772d192f1a7981f651ff9072c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aaa62e91772d192f1a7981f651ff9072c">ptranspose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;subsys, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:aaa62e91772d192f1a7981f651ff9072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial transpose.  <a href="#aaa62e91772d192f1a7981f651ff9072c">More...</a><br /></td></tr>
<tr class="separator:aaa62e91772d192f1a7981f651ff9072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf8dec8978b57214c806094f69e05ca"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4cf8dec8978b57214c806094f69e05ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4cf8dec8978b57214c806094f69e05ca">syspermute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;perm, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:a4cf8dec8978b57214c806094f69e05ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subsystem permutation.  <a href="#a4cf8dec8978b57214c806094f69e05ca">More...</a><br /></td></tr>
<tr class="separator:a4cf8dec8978b57214c806094f69e05ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de352ae53eb3ad8141721b487869b0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af9de352ae53eb3ad8141721b487869b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af9de352ae53eb3ad8141721b487869b0">syspermute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;perm, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> d=2)</td></tr>
<tr class="memdesc:af9de352ae53eb3ad8141721b487869b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subsystem permutation.  <a href="#af9de352ae53eb3ad8141721b487869b0">More...</a><br /></td></tr>
<tr class="separator:af9de352ae53eb3ad8141721b487869b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1ee80e9136dc4c16d964b45d7e188d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2f1ee80e9136dc4c16d964b45d7e188d">rand</a> (double a, double b)</td></tr>
<tr class="memdesc:a2f1ee80e9136dc4c16d964b45d7e188d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real number uniformly distributed in the interval [a, b)  <a href="#a2f1ee80e9136dc4c16d964b45d7e188d">More...</a><br /></td></tr>
<tr class="separator:a2f1ee80e9136dc4c16d964b45d7e188d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5647999b1ea7fb98e2fa7cb2f1a59af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae5647999b1ea7fb98e2fa7cb2f1a59af">rand</a> (<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> a, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> b)</td></tr>
<tr class="memdesc:ae5647999b1ea7fb98e2fa7cb2f1a59af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random big integer uniformly distributed in the interval [a, b].  <a href="#ae5647999b1ea7fb98e2fa7cb2f1a59af">More...</a><br /></td></tr>
<tr class="separator:ae5647999b1ea7fb98e2fa7cb2f1a59af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e295b33fd56735f0bffb21d61d21dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab2e295b33fd56735f0bffb21d61d21dd">randidx</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> a=std::numeric_limits&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;::min(), <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> b=std::numeric_limits&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;::max())</td></tr>
<tr class="memdesc:ab2e295b33fd56735f0bffb21d61d21dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random index (idx) uniformly distributed in the interval [a, b].  <a href="#ab2e295b33fd56735f0bffb21d61d21dd">More...</a><br /></td></tr>
<tr class="separator:ab2e295b33fd56735f0bffb21d61d21dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4bd67e5334b4a9ac09216e8fe37249"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6e4bd67e5334b4a9ac09216e8fe37249"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6e4bd67e5334b4a9ac09216e8fe37249">rand</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols, double a=0, double b=1)</td></tr>
<tr class="memdesc:a6e4bd67e5334b4a9ac09216e8fe37249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random matrix with entries uniformly distributed in the interval [a, b)  <a href="#a6e4bd67e5334b4a9ac09216e8fe37249">More...</a><br /></td></tr>
<tr class="separator:a6e4bd67e5334b4a9ac09216e8fe37249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884c04674e908e0ee6160a8d37623766"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a884c04674e908e0ee6160a8d37623766"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a884c04674e908e0ee6160a8d37623766">rand</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols, double a, double b)</td></tr>
<tr class="memdesc:a884c04674e908e0ee6160a8d37623766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real matrix with entries uniformly distributed in the interval [a, b), specialization for double matrices (<a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a>)  <a href="#a884c04674e908e0ee6160a8d37623766">More...</a><br /></td></tr>
<tr class="separator:a884c04674e908e0ee6160a8d37623766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6ed04b1092ce25ceed3ce4e7136b48"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2a6ed04b1092ce25ceed3ce4e7136b48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2a6ed04b1092ce25ceed3ce4e7136b48">rand</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols, double a, double b)</td></tr>
<tr class="memdesc:a2a6ed04b1092ce25ceed3ce4e7136b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random complex matrix with entries (both real and imaginary) uniformly distributed in the interval [a, b), specialization for complex matrices (<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a>)  <a href="#a2a6ed04b1092ce25ceed3ce4e7136b48">More...</a><br /></td></tr>
<tr class="separator:a2a6ed04b1092ce25ceed3ce4e7136b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb9fb000b5bb9056653c3d2c10a1d65"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aeeb9fb000b5bb9056653c3d2c10a1d65"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aeeb9fb000b5bb9056653c3d2c10a1d65">randn</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols, double mean=0, double <a class="el" href="namespaceqpp.html#a5dac002761cbcfb72cdb6a573e2689c3">sigma</a>=1)</td></tr>
<tr class="memdesc:aeeb9fb000b5bb9056653c3d2c10a1d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random matrix with entries normally distributed in N(mean, sigma)  <a href="#aeeb9fb000b5bb9056653c3d2c10a1d65">More...</a><br /></td></tr>
<tr class="separator:aeeb9fb000b5bb9056653c3d2c10a1d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a175c6092603d8d4518ede7176fce"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a793a175c6092603d8d4518ede7176fce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a793a175c6092603d8d4518ede7176fce">randn</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols, double mean, double <a class="el" href="namespaceqpp.html#a5dac002761cbcfb72cdb6a573e2689c3">sigma</a>)</td></tr>
<tr class="memdesc:a793a175c6092603d8d4518ede7176fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real matrix with entries normally distributed in N(mean, sigma), specialization for double matrices (<a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a>)  <a href="#a793a175c6092603d8d4518ede7176fce">More...</a><br /></td></tr>
<tr class="separator:a793a175c6092603d8d4518ede7176fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b7474e691f0a85940ef6265645a716"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a97b7474e691f0a85940ef6265645a716"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a97b7474e691f0a85940ef6265645a716">randn</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> rows, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> cols, double mean, double <a class="el" href="namespaceqpp.html#a5dac002761cbcfb72cdb6a573e2689c3">sigma</a>)</td></tr>
<tr class="memdesc:a97b7474e691f0a85940ef6265645a716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random complex matrix with entries (both real and imaginary) normally distributed in N(mean, sigma), specialization for complex matrices (<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a>)  <a href="#a97b7474e691f0a85940ef6265645a716">More...</a><br /></td></tr>
<tr class="separator:a97b7474e691f0a85940ef6265645a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab967280114b9e2003bd559c840a5f0e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab967280114b9e2003bd559c840a5f0e6">randn</a> (double mean=0, double <a class="el" href="namespaceqpp.html#a5dac002761cbcfb72cdb6a573e2689c3">sigma</a>=1)</td></tr>
<tr class="memdesc:ab967280114b9e2003bd559c840a5f0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real number (double) normally distributed in N(mean, sigma)  <a href="#ab967280114b9e2003bd559c840a5f0e6">More...</a><br /></td></tr>
<tr class="separator:ab967280114b9e2003bd559c840a5f0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbd539cb9973433e650a86b0f42d2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5bbd539cb9973433e650a86b0f42d2f4">randU</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> D=2)</td></tr>
<tr class="memdesc:a5bbd539cb9973433e650a86b0f42d2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random unitary matrix.  <a href="#a5bbd539cb9973433e650a86b0f42d2f4">More...</a><br /></td></tr>
<tr class="separator:a5bbd539cb9973433e650a86b0f42d2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4eff328bfb8e86da723c6659052d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7e4eff328bfb8e86da723c6659052d90">randV</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> Din, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> Dout)</td></tr>
<tr class="memdesc:a7e4eff328bfb8e86da723c6659052d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random isometry matrix.  <a href="#a7e4eff328bfb8e86da723c6659052d90">More...</a><br /></td></tr>
<tr class="separator:a7e4eff328bfb8e86da723c6659052d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b62ef049b9e0d0109d54c0c45683498"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2b62ef049b9e0d0109d54c0c45683498">randkraus</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N, <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> D=2)</td></tr>
<tr class="memdesc:a2b62ef049b9e0d0109d54c0c45683498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of random Kraus operators.  <a href="#a2b62ef049b9e0d0109d54c0c45683498">More...</a><br /></td></tr>
<tr class="separator:a2b62ef049b9e0d0109d54c0c45683498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeabb6405223cf7cd2b0084dc141ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afaeabb6405223cf7cd2b0084dc141ec3">randH</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> D=2)</td></tr>
<tr class="memdesc:afaeabb6405223cf7cd2b0084dc141ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random Hermitian matrix.  <a href="#afaeabb6405223cf7cd2b0084dc141ec3">More...</a><br /></td></tr>
<tr class="separator:afaeabb6405223cf7cd2b0084dc141ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9ba9e2566a16832dac2b7ea388a1b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9d9ba9e2566a16832dac2b7ea388a1b1">randket</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> D=2)</td></tr>
<tr class="memdesc:a9d9ba9e2566a16832dac2b7ea388a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random normalized ket (pure state vector)  <a href="#a9d9ba9e2566a16832dac2b7ea388a1b1">More...</a><br /></td></tr>
<tr class="separator:a9d9ba9e2566a16832dac2b7ea388a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179bc0022d2b0365d8d7bd0b7767a4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a179bc0022d2b0365d8d7bd0b7767a4db">randrho</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> D=2)</td></tr>
<tr class="memdesc:a179bc0022d2b0365d8d7bd0b7767a4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random density matrix.  <a href="#a179bc0022d2b0365d8d7bd0b7767a4db">More...</a><br /></td></tr>
<tr class="separator:a179bc0022d2b0365d8d7bd0b7767a4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aa968f8779cff8a973798557f38bc3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a34aa968f8779cff8a973798557f38bc3">randperm</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N)</td></tr>
<tr class="memdesc:a34aa968f8779cff8a973798557f38bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random uniformly distributed permutation.  <a href="#a34aa968f8779cff8a973798557f38bc3">More...</a><br /></td></tr>
<tr class="separator:a34aa968f8779cff8a973798557f38bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80909feea5c4e3ab6fbf5394f9485a1f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a80909feea5c4e3ab6fbf5394f9485a1f">randprob</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N)</td></tr>
<tr class="memdesc:a80909feea5c4e3ab6fbf5394f9485a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random probability vector uniformly distributed over the probability simplex.  <a href="#a80909feea5c4e3ab6fbf5394f9485a1f">More...</a><br /></td></tr>
<tr class="separator:a80909feea5c4e3ab6fbf5394f9485a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc09834bbfdd7aebe3cd95d01c99b869"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abc09834bbfdd7aebe3cd95d01c99b869">uniform</a> (<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> N)</td></tr>
<tr class="memdesc:abc09834bbfdd7aebe3cd95d01c99b869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform probability distribution vector.  <a href="#abc09834bbfdd7aebe3cd95d01c99b869">More...</a><br /></td></tr>
<tr class="separator:abc09834bbfdd7aebe3cd95d01c99b869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231fc8c64c2d14bb701eb783d9d1e3a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6231fc8c64c2d14bb701eb783d9d1e3a">marginalX</a> (const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;probXY)</td></tr>
<tr class="memdesc:a6231fc8c64c2d14bb701eb783d9d1e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginal distribution.  <a href="#a6231fc8c64c2d14bb701eb783d9d1e3a">More...</a><br /></td></tr>
<tr class="separator:a6231fc8c64c2d14bb701eb783d9d1e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a770cae0d7a05ca4590dec72390ebc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7a770cae0d7a05ca4590dec72390ebc7">marginalY</a> (const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;probXY)</td></tr>
<tr class="memdesc:a7a770cae0d7a05ca4590dec72390ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginal distribution.  <a href="#a7a770cae0d7a05ca4590dec72390ebc7">More...</a><br /></td></tr>
<tr class="separator:a7a770cae0d7a05ca4590dec72390ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ac36cfcd131c44a35faf86c5bf4ebd"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a01ac36cfcd131c44a35faf86c5bf4ebd"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a01ac36cfcd131c44a35faf86c5bf4ebd">avg</a> (const std::vector&lt; double &gt; &amp;prob, const Container &amp;X, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a01ac36cfcd131c44a35faf86c5bf4ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average.  <a href="#a01ac36cfcd131c44a35faf86c5bf4ebd">More...</a><br /></td></tr>
<tr class="separator:a01ac36cfcd131c44a35faf86c5bf4ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2dcd205e0f0075b067ea46d3755982"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aaf2dcd205e0f0075b067ea46d3755982"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aaf2dcd205e0f0075b067ea46d3755982">cov</a> (const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;probXY, const Container &amp;X, const Container &amp;Y, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:aaf2dcd205e0f0075b067ea46d3755982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covariance.  <a href="#aaf2dcd205e0f0075b067ea46d3755982">More...</a><br /></td></tr>
<tr class="separator:aaf2dcd205e0f0075b067ea46d3755982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a9f78049d7bf991a2d3c9bd81a05dd"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a88a9f78049d7bf991a2d3c9bd81a05dd"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a88a9f78049d7bf991a2d3c9bd81a05dd">var</a> (const std::vector&lt; double &gt; &amp;prob, const Container &amp;X, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a88a9f78049d7bf991a2d3c9bd81a05dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variance.  <a href="#a88a9f78049d7bf991a2d3c9bd81a05dd">More...</a><br /></td></tr>
<tr class="separator:a88a9f78049d7bf991a2d3c9bd81a05dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dac002761cbcfb72cdb6a573e2689c3"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a5dac002761cbcfb72cdb6a573e2689c3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5dac002761cbcfb72cdb6a573e2689c3">sigma</a> (const std::vector&lt; double &gt; &amp;prob, const Container &amp;X, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a5dac002761cbcfb72cdb6a573e2689c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard deviation.  <a href="#a5dac002761cbcfb72cdb6a573e2689c3">More...</a><br /></td></tr>
<tr class="separator:a5dac002761cbcfb72cdb6a573e2689c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5cef3ac2601b63d4afef384fd7499b"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:acc5cef3ac2601b63d4afef384fd7499b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acc5cef3ac2601b63d4afef384fd7499b">cor</a> (const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;probXY, const Container &amp;X, const Container &amp;Y, typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:acc5cef3ac2601b63d4afef384fd7499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation.  <a href="#acc5cef3ac2601b63d4afef384fd7499b">More...</a><br /></td></tr>
<tr class="separator:acc5cef3ac2601b63d4afef384fd7499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a> = 1e-10</td></tr>
<tr class="memdesc:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in <a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d" title="Eigen expression ostream manipulator. ">qpp::disp()</a> for setting to zero numbers that have their absolute value smaller than <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94" title="Used in qpp::disp() for setting to zero numbers that have their absolute value smaller than qpp::chop...">qpp::chop</a>.  <a href="#a3a6d2c509bdcf240869e1bebb3be4e94">More...</a><br /></td></tr>
<tr class="separator:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6">eps</a> = 1e-12</td></tr>
<tr class="memdesc:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to decide whether a number or expression in double precision is zero or not.  <a href="#a9a99ccccd473a9006dfaadb5761ac4f6">More...</a><br /></td></tr>
<tr class="separator:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea80be6c57ee43e43aa9629942cd3608"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aea80be6c57ee43e43aa9629942cd3608">maxn</a> = 64</td></tr>
<tr class="memdesc:aea80be6c57ee43e43aa9629942cd3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of allowed qubits/qudits (subsystems)  <a href="#aea80be6c57ee43e43aa9629942cd3608">More...</a><br /></td></tr>
<tr class="separator:aea80be6c57ee43e43aa9629942cd3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c04db6f636b236d64fddb069bef492"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a73c04db6f636b236d64fddb069bef492">pi</a> = 3.141592653589793238462643383279502884</td></tr>
<tr class="memdesc:a73c04db6f636b236d64fddb069bef492"><td class="mdescLeft">&#160;</td><td class="mdescRight"><img class="formulaInl" alt="$ \pi $" src="form_12.png"/>  <a href="#a73c04db6f636b236d64fddb069bef492">More...</a><br /></td></tr>
<tr class="separator:a73c04db6f636b236d64fddb069bef492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c7e10fa94db0755cb937250144630"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aca5c7e10fa94db0755cb937250144630">ee</a> = 2.718281828459045235360287471352662497</td></tr>
<tr class="memdesc:aca5c7e10fa94db0755cb937250144630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base of natural logarithm, <img class="formulaInl" alt="$e$" src="form_13.png"/>.  <a href="#aca5c7e10fa94db0755cb937250144630">More...</a><br /></td></tr>
<tr class="separator:aca5c7e10fa94db0755cb937250144630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd9c0f42f21f1d3b29868b6a8cac4c7"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aecd9c0f42f21f1d3b29868b6a8cac4c7">infty</a> = std::numeric_limits&lt;double&gt;::max()</td></tr>
<tr class="memdesc:aecd9c0f42f21f1d3b29868b6a8cac4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to denote infinity in double precision.  <a href="#aecd9c0f42f21f1d3b29868b6a8cac4c7">More...</a><br /></td></tr>
<tr class="separator:aecd9c0f42f21f1d3b29868b6a8cac4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Quantum++ main namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad199ade0836f0d8488e7f6c7c8aa1949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad199ade0836f0d8488e7f6c7c8aa1949">&#9670;&nbsp;</a></span>bigint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">qpp::bigint</a> = typedef long long int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Big integer. </p>

</div>
</div>
<a id="a8886624a4a55a9b45c96a623a20bf163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8886624a4a55a9b45c96a623a20bf163">&#9670;&nbsp;</a></span>bra</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a8886624a4a55a9b45c96a623a20bf163">qpp::bra</a> = typedef Eigen::RowVectorXcd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen row vector. </p>

</div>
</div>
<a id="ab0de67006716bdc8fae52c6a49259276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de67006716bdc8fae52c6a49259276">&#9670;&nbsp;</a></span>cmat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">qpp::cmat</a> = typedef Eigen::MatrixXcd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen matrix. </p>

</div>
</div>
<a id="aad7ccc50a6b139279d7b56d07112b183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7ccc50a6b139279d7b56d07112b183">&#9670;&nbsp;</a></span>cplx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">qpp::cplx</a> = typedef std::complex&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex number in double precision. </p>

</div>
</div>
<a id="a923e2becc99eb818c04c71ae913902ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923e2becc99eb818c04c71ae913902ff">&#9670;&nbsp;</a></span>dmat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">qpp::dmat</a> = typedef Eigen::MatrixXd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real (double precision) dynamic Eigen matrix. </p>

</div>
</div>
<a id="a07c62992d1a236f062887990eea26b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c62992d1a236f062887990eea26b15">&#9670;&nbsp;</a></span>dyn_col_vect</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">qpp::dyn_col_vect</a> = typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen column vector over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// type of colvect is Eigen::Matrix&lt;float, Eigen::Dynamic, 1&gt;</span></div><div class="line">dyn_col_vect&lt;float&gt; colvect(2);</div></div><!-- fragment --> 
</div>
</div>
<a id="ac39e7c2b66f0209911cc3afc06223648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39e7c2b66f0209911cc3afc06223648">&#9670;&nbsp;</a></span>dyn_mat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">qpp::dyn_mat</a> = typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen matrix over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// type of mat is Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic&gt;</span></div><div class="line">dyn_mat&lt;float&gt; mat(2, 3);</div></div><!-- fragment --> 
</div>
</div>
<a id="ad94b7f2170b530b81ea9e1d167938589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94b7f2170b530b81ea9e1d167938589">&#9670;&nbsp;</a></span>dyn_row_vect</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#ad94b7f2170b530b81ea9e1d167938589">qpp::dyn_row_vect</a> = typedef Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen row vector over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// type of rowvect is Eigen::Matrix&lt;float, 1, Eigen::Dynamic&gt;</span></div><div class="line">dyn_row_vect&lt;float&gt; rowvect(3);</div></div><!-- fragment --> 
</div>
</div>
<a id="a1f5f7137e8551cf82db04d3b81cdd706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5f7137e8551cf82db04d3b81cdd706">&#9670;&nbsp;</a></span>idx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">qpp::idx</a> = typedef std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-negative integer index. </p>

</div>
</div>
<a id="a5d7185dfc7bee58c937abc243c3692ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7185dfc7bee58c937abc243c3692ea">&#9670;&nbsp;</a></span>ket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">qpp::ket</a> = typedef Eigen::VectorXcd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen column vector. </p>

</div>
</div>
<a id="adf4dc551c8858cac37c90b561c5767cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4dc551c8858cac37c90b561c5767cc">&#9670;&nbsp;</a></span>to_void</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#adf4dc551c8858cac37c90b561c5767cc">qpp::to_void</a> = typedef typename <a class="el" href="structqpp_1_1make__void.html">make_void</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template that implements the proposal for void_t. </p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3a4cb16d97f9cc763bd133b64f2b6f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4cb16d97f9cc763bd133b64f2b6f6d">&#9670;&nbsp;</a></span>absm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::absm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix absolute value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix absolute value of <em>A</em> </dd></dl>

</div>
</div>
<a id="a3e9825a190c56286a68989b67620bbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9825a190c56286a68989b67620bbb9">&#9670;&nbsp;</a></span>abssq() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute values squared of an STL-like range of complex numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the range absolute values squared </dd></dl>

</div>
</div>
<a id="a31fc4d84b7de3be27d575d823611ed08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fc4d84b7de3be27d575d823611ed08">&#9670;&nbsp;</a></span>abssq() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute values squared of an STL-like container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the container's absolute values squared </dd></dl>

</div>
</div>
<a id="a07276990fbab7f30c1e9ad0a339e5215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07276990fbab7f30c1e9ad0a339e5215">&#9670;&nbsp;</a></span>abssq() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute values squared of an Eigen expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the absolute values squared </dd></dl>

</div>
</div>
<a id="aba2b3538ec37539e56f77addfb9ea1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2b3538ec37539e56f77addfb9ea1dd">&#9670;&nbsp;</a></span>adjoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::adjoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adjoint (Hermitian conjugate) of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="af2f54909fe5801ad4bc179be28ad7a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f54909fe5801ad4bc179be28ad7a41">&#9670;&nbsp;</a></span>anticomm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived1::Scalar&gt; qpp::anticomm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anti-commutator. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa4c1b998a518e655645a0285f90550e3" title="Commutator. ">qpp::comm()</a></dd></dl>
<p>Anti-commutator <img class="formulaInl" alt="$ \{A,B\} = AB + BA $" src="form_35.png"/>. Both <em>A</em> and <em>B</em> must be Eigen expressions over the same scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">B</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anti-commutator <img class="formulaInl" alt="$AB +BA$" src="form_36.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a6cc60c95fa5b4158e153269699d245bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc60c95fa5b4158e153269699d245bc">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived1::Scalar&gt; qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gate <em>A</em> applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a id="a08b0262b2151f6e37a7e86ca8213597f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b0262b2151f6e37a7e86ca8213597f">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived1::Scalar&gt; qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gate <em>A</em> applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a id="a1b9b7bce27da056e972cc75aa7473e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9b7bce27da056e972cc75aa7473e36">&#9670;&nbsp;</a></span>apply() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the density matrix <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

</div>
</div>
<a id="a4795b6b4ac7a790a6e5197c9bfb3080a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4795b6b4ac7a790a6e5197c9bfb3080a">&#9670;&nbsp;</a></span>apply() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the Kraus operators <em>Ks</em> are applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

</div>
</div>
<a id="a8ef6d510aeae580845ba98e8c8ecfa58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef6d510aeae580845ba98e8c8ecfa58">&#9670;&nbsp;</a></span>apply() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the Kraus operators <em>Ks</em> are applied </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

</div>
</div>
<a id="a1e583ad0b10c1250e39c9d9bc8bade78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e583ad0b10c1250e39c9d9bc8bade78">&#9670;&nbsp;</a></span>applyCTRL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived1::Scalar&gt; qpp::applyCTRL </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classqpp_1_1_gates.html#aee777349bd3cdba2e47b043b0ccb6ad4" title="Generates the multi-partite multiple-controlled-A gate in matrix form. ">qpp::Gates::CTRL()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em>. Also, all control subsystems in <em>ctrl</em> must have the same dimension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">ctrl</td><td>Control subsystem indexes </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CTRL-A gate applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a id="a3c3fc9e33a8a12fe082359b2b86bf504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3fc9e33a8a12fe082359b2b86bf504">&#9670;&nbsp;</a></span>applyCTRL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived1::Scalar&gt; qpp::applyCTRL </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classqpp_1_1_gates.html#aee777349bd3cdba2e47b043b0ccb6ad4" title="Generates the multi-partite multiple-controlled-A gate in matrix form. ">qpp::Gates::CTRL()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">ctrl</td><td>Control subsystem indexes </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CTRL-A gate applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a id="a01ac36cfcd131c44a35faf86c5bf4ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ac36cfcd131c44a35faf86c5bf4ebd">&#9670;&nbsp;</a></span>avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::avg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>Real probability vector representing the probability distribution of <em>X</em> </td></tr>
    <tr><td class="paramname">X</td><td>Real random variable values represented by an STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Average of <em>X</em> </dd></dl>

</div>
</div>
<a id="a7e5c413d74d838e78264444307e81576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5c413d74d838e78264444307e81576">&#9670;&nbsp;</a></span>bloch2rho()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::bloch2rho </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the density matrix corresponding to the 3-dimensional real Bloch vector <em>r</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a2b8b1ec9320981f9b5d6984810f14737" title="Computes the 3-dimensional real Bloch vector corresponding to the qubit density matrix A...">qpp::rho2bloch()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>3-dimensional real vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Qubit density matrix </dd></dl>

</div>
</div>
<a id="ac08330f1578fa6b6e382a80132dffb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08330f1578fa6b6e382a80132dffb46">&#9670;&nbsp;</a></span>choi2kraus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::choi2kraus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Orthogonal Kraus operators from Choi matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a9f23aa8ee0eb007532b29ada39091d4f" title="Choi matrix. ">qpp::kraus2choi()</a></dd></dl>
<p>Extracts a set of orthogonal (under Hilbert-Schmidt operator norm) Kraus operators from the Choi matrix <em>A</em> </p>
<dl class="section note"><dt>Note</dt><dd>The Kraus operators satisfy <img class="formulaInl" alt="$Tr(K_i^\dagger K_j)=\delta_{ij}$" src="form_62.png"/> for all <img class="formulaInl" alt="$i\neq j$" src="form_63.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Choi matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of orthogonal Kraus operators </dd></dl>

</div>
</div>
<a id="a8b5fb595977b62ea764f9362828678f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5fb595977b62ea764f9362828678f2">&#9670;&nbsp;</a></span>choi2super()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::choi2super </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Choi matrix to superoperator matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ad2b8ee9e2f9b51a281f7c42f61571c9a" title="Converts superoperator matrix to Choi matrix. ">qpp::super2choi()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Choi matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Superoperator matrix </dd></dl>

</div>
</div>
<a id="aa4c1b998a518e655645a0285f90550e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c1b998a518e655645a0285f90550e3">&#9670;&nbsp;</a></span>comm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived1::Scalar&gt; qpp::comm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commutator. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#af2f54909fe5801ad4bc179be28ad7a41" title="Anti-commutator. ">qpp::anticomm()</a></dd></dl>
<p>Commutator <img class="formulaInl" alt="$ [A,B] = AB - BA $" src="form_33.png"/>. Both <em>A</em> and <em>B</em> must be Eigen expressions over the same scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">B</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Commutator <img class="formulaInl" alt="$AB -BA$" src="form_34.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a87ad5b3e58dedde05467ac1961e44892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ad5b3e58dedde05467ac1961e44892">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; qpp::complement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the complement of a subsystem vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsys</td><td>Subsystem vector </td></tr>
    <tr><td class="paramname">N</td><td>Total number of systems </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complement of <em>subsys</em> with respect to the set <img class="formulaInl" alt="$\{0, 1, \ldots, N - 1\}$" src="form_38.png"/> </dd></dl>

</div>
</div>
<a id="a9a0cdf917f1a5e398e9978fb36141a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0cdf917f1a5e398e9978fb36141a27">&#9670;&nbsp;</a></span>compperm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt; qpp::compperm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compose permutations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">sigma</td><td>Permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Composition of the permutations <em>perm</em> <img class="formulaInl" alt="$\circ$" src="form_43.png"/> <em>sigma</em> = perm(sigma) </dd></dl>

</div>
</div>
<a id="a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">&#9670;&nbsp;</a></span>concurrence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::concurrence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wootters concurrence of the bi-partite qubit mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wootters concurrence </dd></dl>

</div>
</div>
<a id="ad430508f45480e4d7a8ac83ae7d00aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad430508f45480e4d7a8ac83ae7d00aae">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::conjugate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex conjugate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex conjugate of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a33f4dd20b7c8cdd7d07c596e5b83ee2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f4dd20b7c8cdd7d07c596e5b83ee2e">&#9670;&nbsp;</a></span>contfrac2x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::contfrac2x </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em> = <code><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Real representation of a simple continued fraction. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ace6723d802f5d4c15f0d14fa1abee7bb" title="Simple continued fraction expansion. ">qpp::x2contfrac()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em>N</em> is greater than the size of <em>cf</em> (by default it is), then all terms in <em>cf</em> are considered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>Integer vector containing the simple continued fraction expansion </td></tr>
    <tr><td class="paramname">N</td><td>Number of terms considered in the continued fraction expansion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real representation of the simple continued fraction </dd></dl>

</div>
</div>
<a id="acc5cef3ac2601b63d4afef384fd7499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5cef3ac2601b63d4afef384fd7499b">&#9670;&nbsp;</a></span>cor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::cor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;&#160;</td>
          <td class="paramname"><em>probXY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probXY</td><td>Real matrix representing the joint probability distribution of <em>X</em> and <em>Y</em> in lexicographical order (<em>X</em> labels the rows, <em>Y</em> labels the columns) </td></tr>
    <tr><td class="paramname">X</td><td>Real random variable values represented by an STL-like container </td></tr>
    <tr><td class="paramname">Y</td><td>Real random variable values represented by an STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correlation of <em>X</em> and <em>Y</em> </dd></dl>

</div>
</div>
<a id="a369c7a2f9f27121178519ddba186fbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369c7a2f9f27121178519ddba186fbcd">&#9670;&nbsp;</a></span>cosm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::cosm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix cosine of <em>A</em> </dd></dl>

</div>
</div>
<a id="aaf2dcd205e0f0075b067ea46d3755982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2dcd205e0f0075b067ea46d3755982">&#9670;&nbsp;</a></span>cov()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;&#160;</td>
          <td class="paramname"><em>probXY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probXY</td><td>Real matrix representing the joint probability distribution of <em>X</em> and <em>Y</em> in lexicographical order (<em>X</em> labels the rows, <em>Y</em> labels the columns) </td></tr>
    <tr><td class="paramname">X</td><td>Real random variable values represented by an STL-like container </td></tr>
    <tr><td class="paramname">Y</td><td>Real random variable values represented by an STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Covariance of <em>X</em> and <em>Y</em> </dd></dl>

</div>
</div>
<a id="a18e336b2319f89d7817aa7979de9190f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e336b2319f89d7817aa7979de9190f">&#9670;&nbsp;</a></span>cwise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputScalar , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;OutputScalar&gt; qpp::cwise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputScalar(*)(const typename Derived::Scalar &amp;)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">f</td><td>Pointer-to-function from scalars of <em>A</em> to <em>OutputScalar</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Component-wise <img class="formulaInl" alt="$f(A)$" src="form_26.png"/>, as a dynamic matrix over the <em>OutputScalar</em> scalar field </dd></dl>

</div>
</div>
<a id="a4f6e426d47b5bf66afc0f7cc0321e0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6e426d47b5bf66afc0f7cc0321e0eb">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::det </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determinant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determinant of <em>A</em>, as a scalar over the same scalar field as <em>A</em>. Returns <img class="formulaInl" alt="$\pm \infty$" src="form_25.png"/> when the determinant overflows/underflows. </dd></dl>

</div>
</div>
<a id="aee0f3ad6d1892783a265e5d373eec4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0f3ad6d1892783a265e5d373eec4a9">&#9670;&nbsp;</a></span>dirsum() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename T::Scalar&gt; qpp::dirsum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct sum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ac0cea183ce30cc864b16a8583af6b2a6" title="Direct sum power. ">qpp::dirsumpow()</a></dd></dl>
<p>Used to stop the recursion for the variadic template version of <a class="el" href="namespaceqpp.html#aee0f3ad6d1892783a265e5d373eec4a9" title="Direct sum. ">qpp::dirsum()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its argument <em>head</em> </dd></dl>

</div>
</div>
<a id="a1b5af8a1edec21f0b70b2d17657af62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5af8a1edec21f0b70b2d17657af62a">&#9670;&nbsp;</a></span>dirsum() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename T::Scalar&gt; qpp::dirsum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct sum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ac0cea183ce30cc864b16a8583af6b2a6" title="Direct sum power. ">qpp::dirsumpow()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">tail</td><td>Variadic Eigen expression (zero or more parameters) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct sum of all input parameters, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="afe168752758afc9c072a852559d0733b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe168752758afc9c072a852559d0733b">&#9670;&nbsp;</a></span>dirsum() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::dirsum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct sum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ac0cea183ce30cc864b16a8583af6b2a6" title="Direct sum power. ">qpp::dirsumpow()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::vector of Eigen expressions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct sum of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="aca56da00877956ddae60bdb12e2964ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca56da00877956ddae60bdb12e2964ae">&#9670;&nbsp;</a></span>dirsum() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::dirsum </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct sum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ac0cea183ce30cc864b16a8583af6b2a6" title="Direct sum power. ">qpp::dirsumpow()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::initializer_list of Eigen expressions, such as <em>{A1</em>, A2, ... ,Ak} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct sum of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="ac0cea183ce30cc864b16a8583af6b2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cea183ce30cc864b16a8583af6b2a6">&#9670;&nbsp;</a></span>dirsumpow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::dirsumpow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct sum power. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aee0f3ad6d1892783a265e5d373eec4a9" title="Direct sum. ">qpp::dirsum()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct sum of <em>A</em> with itself <em>n</em> times <img class="formulaInl" alt="$A^{\oplus n}$" src="form_32.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a4f1805e175751ef749374e3c8499f15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1805e175751ef749374e3c8499f15d">&#9670;&nbsp;</a></span>disp() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a> qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chop</em> = <code><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen expression ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">chop</td><td>Set to zero the elements smaller in absolute value than <em>chop</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of <a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">qpp::internal::IOManipEigen</a> </dd></dl>

</div>
</div>
<a id="a815b8e5cf5cd3ab4c463bf53eb550dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815b8e5cf5cd3ab4c463bf53eb550dbf">&#9670;&nbsp;</a></span>disp() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a> qpp::disp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chop</em> = <code><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex number ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>Complex number (or any other type implicitly cast-able to std::complex&lt;double&gt;) </td></tr>
    <tr><td class="paramname">chop</td><td>Set to zero the elements smaller in absolute value than <em>chop</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of <a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">qpp::internal::IOManipEigen</a> </dd></dl>

</div>
</div>
<a id="a7cc152d12deb461b1a0b1d8eac7c9815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc152d12deb461b1a0b1d8eac7c9815">&#9670;&nbsp;</a></span>disp() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt;InputIterator&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of <a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">qpp::internal::IOManipRange</a> </dd></dl>

</div>
</div>
<a id="a511ed948dfcfc43535412d9cc9a586a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511ed948dfcfc43535412d9cc9a586a6">&#9670;&nbsp;</a></span>disp() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt;typename Container::const_iterator&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard container ostream manipulator. The container must support std::begin(), std::end() and forward iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of <a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">qpp::internal::IOManipRange</a> </dd></dl>

</div>
</div>
<a id="ad7a947f46b0a59a26de227e1c4d786b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a947f46b0a59a26de227e1c4d786b9">&#9670;&nbsp;</a></span>disp() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">internal::IOManipPointer</a>&lt;PointerType&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const PointerType *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-style pointer ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the first element </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to be displayed </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of <a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">qpp::internal::IOManipPointer</a> </dd></dl>

</div>
</div>
<a id="a0d115963145ca884c5d9ef8f3b18bf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d115963145ca884c5d9ef8f3b18bf83">&#9670;&nbsp;</a></span>egcd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>, <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&gt; qpp::egcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended greatest common divisor of two integers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a51f32c6f38bc3b174ee257b26c7750a2" title="Greatest common divisor of two integers. ">qpp::gcd()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer </td></tr>
    <tr><td class="paramname">b</td><td>Integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Integer <img class="formulaInl" alt="$m$" src="form_49.png"/>, 2. Integer <img class="formulaInl" alt="$n$" src="form_50.png"/>, and 3. Non-negative integer <img class="formulaInl" alt="$gcd(a, b)$" src="form_51.png"/> such that <img class="formulaInl" alt="$ma + nb = gcd(a, b)$" src="form_52.png"/> </dd></dl>

</div>
</div>
<a id="afa6eb666202bc76f713c4deadf8624a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6eb666202bc76f713c4deadf8624a6">&#9670;&nbsp;</a></span>eig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::eig </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full eigen decomposition. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#acbb48ecd842d8f6a3938e3e5b9a36506" title="Full eigen decomposition of Hermitian expression. ">qpp::heig()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of: 1. Eigenvalues of <em>A</em>, as a complex dynamic column vector, and 2. Eigenvectors of <em>A</em>, as columns of a complex dynamic matrix </dd></dl>

</div>
</div>
<a id="a9fe919380a14cf18d8c845ee2e3a8f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe919380a14cf18d8c845ee2e3a8f31">&#9670;&nbsp;</a></span>entanglement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::entanglement </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entanglement of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the von-Neumann entropy of the reduced density matrix of one of the subsystems </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a922127fa0dd6659113c8277de8731c41" title="von-Neumann entropy of the density matrix A ">qpp::entropy()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entanglement, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="a2bcefa3e8c655db5fa8ff104b25082d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcefa3e8c655db5fa8ff104b25082d0">&#9670;&nbsp;</a></span>entanglement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::entanglement </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entanglement of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the von-Neumann entropy of the reduced density matrix of one of the subsystems </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a922127fa0dd6659113c8277de8731c41" title="von-Neumann entropy of the density matrix A ">qpp::entropy()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entanglement, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="a922127fa0dd6659113c8277de8731c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922127fa0dd6659113c8277de8731c41">&#9670;&nbsp;</a></span>entropy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::entropy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>von-Neumann entropy of the density matrix <em>A</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>von-Neumann entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="a11fd22e80ba664a4585ce87b45262efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fd22e80ba664a4585ce87b45262efd">&#9670;&nbsp;</a></span>entropy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::entropy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shannon entropy of the probability distribution <em>prob</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>Real probability vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shannon entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="a2f9801291f336021f67fd1a022664c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9801291f336021f67fd1a022664c24">&#9670;&nbsp;</a></span>evals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt; qpp::evals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalues. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a322665174fcacffbdf82dd04139d667e" title="Hermitian eigenvalues. ">qpp::hevals()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of <em>A</em>, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a id="acc9597bacc39c501eb8e2e5e8530fcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9597bacc39c501eb8e2e5e8530fcd8">&#9670;&nbsp;</a></span>evects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::evects </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvectors. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#abeadaf6395c78a52339bec119c4a331b" title="Hermitian eigenvectors. ">qpp::hevects()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvectors of <em>A</em>, as columns of a complex dynamic matrix </dd></dl>

</div>
</div>
<a id="a6855dd77c49ae0b96baf10c12b4bc722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6855dd77c49ae0b96baf10c12b4bc722">&#9670;&nbsp;</a></span>expm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::expm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix exponential of <em>A</em> </dd></dl>

</div>
</div>
<a id="a048622e398319b61f9ea62a6c66e67fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048622e398319b61f9ea62a6c66e67fb">&#9670;&nbsp;</a></span>factors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&gt; qpp::factors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prime factor decomposition. </p>
<dl class="section note"><dt>Note</dt><dd>Runs in <img class="formulaInl" alt="$\mathcal{O}(\sqrt{n})$" src="form_44.png"/> time complexity</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer different from 0, 1 or -1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer vector containing the factors </dd></dl>

</div>
</div>
<a id="a659b50e01fa0b26089d3944c2c56601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659b50e01fa0b26089d3944c2c56601a">&#9670;&nbsp;</a></span>funm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::funm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>(*)(const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &amp;)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functional calculus f(A) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">f</td><td>Pointer-to-function from complex to complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em><img class="formulaInl" alt="$f(A)$" src="form_26.png"/></em> </dd></dl>

</div>
</div>
<a id="a51f32c6f38bc3b174ee257b26c7750a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f32c6f38bc3b174ee257b26c7750a2">&#9670;&nbsp;</a></span>gcd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::gcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greatest common divisor of two integers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a88aee2554ea53f80d42b6b50ab9bca2c" title="Least common multiple of two integers. ">qpp::lcm()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer </td></tr>
    <tr><td class="paramname">b</td><td>Integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of <em>a</em> and <em>b</em> </dd></dl>

</div>
</div>
<a id="a30154e60ca47ab955ac06b5a31360f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30154e60ca47ab955ac06b5a31360f2a">&#9670;&nbsp;</a></span>gcd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::gcd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greatest common divisor of a list of integers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a88aee2554ea53f80d42b6b50ab9bca2c" title="Least common multiple of two integers. ">qpp::lcm()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>List of integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of all numbers in <em>as</em> </dd></dl>

</div>
</div>
<a id="a100bf63d3dabba74e049aff37ea7e383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100bf63d3dabba74e049aff37ea7e383">&#9670;&nbsp;</a></span>gconcurrence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::gconcurrence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>G-concurrence of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Both local dimensions must be equal</dd></dl>
<p>Uses <a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. ">qpp::logdet()</a> to avoid overflows </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. ">qpp::logdet()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>G-concurrence </dd></dl>

</div>
</div>
<a id="a9bd864d5b7c0edfe047589282d701950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd864d5b7c0edfe047589282d701950">&#9670;&nbsp;</a></span>grams() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::vector of Eigen expressions as column vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of <em>As</em> as columns of a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="ae40f14c3ec60bace8ab14a733d161932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40f14c3ec60bace8ab14a733d161932">&#9670;&nbsp;</a></span>grams() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::initializer_list of Eigen expressions as column vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of <em>As</em> as columns of a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="aa4917f28299b0430203972045b8cf377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4917f28299b0430203972045b8cf377">&#9670;&nbsp;</a></span>grams() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, the input vectors are the columns of <em>A</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of the columns of <em>A</em>, as columns of a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="acbb48ecd842d8f6a3938e3e5b9a36506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb48ecd842d8f6a3938e3e5b9a36506">&#9670;&nbsp;</a></span>heig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;double&gt;, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::heig </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full eigen decomposition of Hermitian expression. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#afa6eb666202bc76f713c4deadf8624a6" title="Full eigen decomposition. ">qpp::eig()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of: 1. Eigenvalues of <em>A</em>, as a real dynamic column vector, and 2. Eigenvectors of <em>A</em>, as columns of a complex dynamic matrix </dd></dl>

</div>
</div>
<a id="a322665174fcacffbdf82dd04139d667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322665174fcacffbdf82dd04139d667e">&#9670;&nbsp;</a></span>hevals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;double&gt; qpp::hevals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermitian eigenvalues. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a2f9801291f336021f67fd1a022664c24" title="Eigenvalues. ">qpp::evals()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of Hermitian <em>A</em>, as a real dynamic column vector </dd></dl>

</div>
</div>
<a id="abeadaf6395c78a52339bec119c4a331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeadaf6395c78a52339bec119c4a331b">&#9670;&nbsp;</a></span>hevects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::hevects </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermitian eigenvectors. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. ">qpp::evects()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvectors of Hermitian <em>A</em>, as columns of a complex matrix </dd></dl>

</div>
</div>
<a id="a5db8a845e5766ebb3f4eea5177c810de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db8a845e5766ebb3f4eea5177c810de">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a396e880587519c2861caf0bcdfb219a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396e880587519c2861caf0bcdfb219a0">&#9670;&nbsp;</a></span>invperm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt; qpp::invperm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the permutation <em>perm</em> </dd></dl>

</div>
</div>
<a id="a484e5b57c3236108d853fd3b83d64a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484e5b57c3236108d853fd3b83d64a20">&#9670;&nbsp;</a></span>ip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;typename Derived::Scalar&gt; qpp::ip </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalized inner product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Column vector Eigen expression </td></tr>
    <tr><td class="paramname">psi</td><td>Column vector Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes over which <em>phi</em> is defined </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inner product <img class="formulaInl" alt="$\langle \phi_{subsys}|\psi\rangle$" src="form_42.png"/>, as a scalar or column vector over the remaining Hilbert space </dd></dl>

</div>
</div>
<a id="a09aa9dc2db88b74196c4ea59c2c2ff97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aa9dc2db88b74196c4ea59c2c2ff97">&#9670;&nbsp;</a></span>ip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;typename Derived::Scalar&gt; qpp::ip </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalized inner product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Column vector Eigen expression </td></tr>
    <tr><td class="paramname">psi</td><td>Column vector Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes over which <em>phi</em> is defined </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inner product <img class="formulaInl" alt="$\langle \phi_{subsys}|\psi\rangle$" src="form_42.png"/>, as a scalar or column vector over the remaining Hilbert space </dd></dl>

</div>
</div>
<a id="aa2d77d87a676a0b2a04bceeef275aa12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d77d87a676a0b2a04bceeef275aa12">&#9670;&nbsp;</a></span>isprime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qpp::isprime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>k</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Primality test based on the Miller-Rabin's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Integer different from 0, 1 or -1 </td></tr>
    <tr><td class="paramname">k</td><td>Number of iterations. The probability of a false positive is <img class="formulaInl" alt="$2^{-k}$" src="form_55.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the number is (most-likely) prime, false otherwise </dd></dl>

</div>
</div>
<a id="a9f23aa8ee0eb007532b29ada39091d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f23aa8ee0eb007532b29ada39091d4f">&#9670;&nbsp;</a></span>kraus2choi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::kraus2choi </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choi matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ac08330f1578fa6b6e382a80132dffb46" title="Orthogonal Kraus operators from Choi matrix. ">qpp::choi2kraus()</a></dd></dl>
<p>Constructs the Choi matrix of the channel specified by the set of Kraus operators <em>Ks</em> in the standard operator basis <img class="formulaInl" alt="$\{|i\rangle\langle j|\}$" src="form_56.png"/> ordered in lexicographical order, i.e. <img class="formulaInl" alt="$|0\rangle\langle 0|$" src="form_57.png"/>, <img class="formulaInl" alt="$|0\rangle\langle 1|$" src="form_58.png"/> etc.</p>
<dl class="section note"><dt>Note</dt><dd>The superoperator matrix <img class="formulaInl" alt="$S$" src="form_59.png"/> and the Choi matrix <img class="formulaInl" alt="$ C$" src="form_60.png"/> are related by <img class="formulaInl" alt="$ S_{ab,mn} = C_{ma,nb}$" src="form_61.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Choi matrix </dd></dl>

</div>
</div>
<a id="a474d2e8fdbac3fb577c835e5416fecaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474d2e8fdbac3fb577c835e5416fecaa">&#9670;&nbsp;</a></span>kraus2super()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::kraus2super </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Superoperator matrix. </p>
<p>Constructs the superoperator matrix of the channel specified by the set of Kraus operators <em>Ks</em> in the standard operator basis <img class="formulaInl" alt="$\{|i\rangle\langle j|\}$" src="form_56.png"/> ordered in lexicographical order, i.e. <img class="formulaInl" alt="$|0\rangle\langle 0|$" src="form_57.png"/>, <img class="formulaInl" alt="$|0\rangle\langle 1|$" src="form_58.png"/> etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Superoperator matrix </dd></dl>

</div>
</div>
<a id="a9294ebd345fe1c99731bf2b776e610d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9294ebd345fe1c99731bf2b776e610d7">&#9670;&nbsp;</a></span>kron() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename T::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a1693a6d2628b3f3b7f69692cd8af1a9f" title="Kronecker power. ">qpp::kronpow()</a></dd></dl>
<p>Used to stop the recursion for the variadic template version of <a class="el" href="namespaceqpp.html#a9294ebd345fe1c99731bf2b776e610d7" title="Kronecker product. ">qpp::kron()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its argument <em>head</em> </dd></dl>

</div>
</div>
<a id="a7cb4e55a5b10d1cf6d638f0a92687bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb4e55a5b10d1cf6d638f0a92687bf5">&#9670;&nbsp;</a></span>kron() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename T::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a1693a6d2628b3f3b7f69692cd8af1a9f" title="Kronecker power. ">qpp::kronpow()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">tail</td><td>Variadic Eigen expression (zero or more parameters) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all input parameters, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="afaceac83c64e729f98b80f72359ad7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaceac83c64e729f98b80f72359ad7a5">&#9670;&nbsp;</a></span>kron() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a1693a6d2628b3f3b7f69692cd8af1a9f" title="Kronecker power. ">qpp::kronpow()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::vector of Eigen expressions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="ad529abce5ec6d3b7c32ac3e9be65e577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad529abce5ec6d3b7c32ac3e9be65e577">&#9670;&nbsp;</a></span>kron() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a1693a6d2628b3f3b7f69692cd8af1a9f" title="Kronecker power. ">qpp::kronpow()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::initializer_list of Eigen expressions, such as <em>{A1</em>, A2, ... ,Ak} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a id="a1693a6d2628b3f3b7f69692cd8af1a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1693a6d2628b3f3b7f69692cd8af1a9f">&#9670;&nbsp;</a></span>kronpow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::kronpow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker power. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a9294ebd345fe1c99731bf2b776e610d7" title="Kronecker product. ">qpp::kron()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of <em>A</em> with itself <em>n</em> times <img class="formulaInl" alt="$A^{\otimes n}$" src="form_31.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a88aee2554ea53f80d42b6b50ab9bca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88aee2554ea53f80d42b6b50ab9bca2c">&#9670;&nbsp;</a></span>lcm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::lcm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Least common multiple of two integers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a51f32c6f38bc3b174ee257b26c7750a2" title="Greatest common divisor of two integers. ">qpp::gcd()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer </td></tr>
    <tr><td class="paramname">b</td><td>Integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Least common multiple of <em>a</em> and <em>b</em> </dd></dl>

</div>
</div>
<a id="a9af9ed6900ebdce2f6cc5b04047d6b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af9ed6900ebdce2f6cc5b04047d6b67">&#9670;&nbsp;</a></span>lcm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::lcm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Least common multiple of a list of integers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a51f32c6f38bc3b174ee257b26c7750a2" title="Greatest common divisor of two integers. ">qpp::gcd()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>List of integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Least common multiple of all numbers in <em>as</em> </dd></dl>

</div>
</div>
<a id="aea6b39f40a9c9a188a5e0dd244b4bf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b39f40a9c9a188a5e0dd244b4bf08">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads Eigen matrix from a binary file (internal format) in double precision. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a238cf516513837235fbc7d7d283f7b78" title="Saves Eigen expression to a binary file (internal format) in double precision. ">qpp::save()</a></dd></dl>
<p>The template parameter cannot be automatically deduced and must be explicitly provided, depending on the scalar field of the matrix that is being loaded.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic complex matrix from &quot;input.bin&quot;</span></div><div class="line"><a class="code" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> mat = load&lt;cmat&gt;(<span class="stringliteral">&quot;input.bin&quot;</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a624018095ea24ab31e6a9d93c33b3aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624018095ea24ab31e6a9d93c33b3aa2">&#9670;&nbsp;</a></span>loadMATLAB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;::value, <a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt; &gt;::type qpp::loadMATLAB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a complex Eigen dynamic matrix from a MATLAB .mat file,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a37dfa25e02fa2c9939cfeb828f76f86e" title="Saves a complex Eigen dynamic matrix to a MATLAB .mat file,. ">qpp::saveMATLAB()</a></dd></dl>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen ket</span></div><div class="line"><span class="comment">// from the MATLAB file &quot;input.mat&quot;</span></div><div class="line"><a class="code" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a> psi = loadMATLAB&lt;ket&gt;(<span class="stringliteral">&quot;input.mat&quot;</span>);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Complex Eigen type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen dynamic matrix </dd></dl>

</div>
</div>
<a id="af46ebc145afb868fcb89b3e2f98e808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ebc145afb868fcb89b3e2f98e808b">&#9670;&nbsp;</a></span>loadMATLAB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;::value, <a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; &gt;::type qpp::loadMATLAB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a non-complex Eigen dynamic matrix from a MATLAB .mat file,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a37dfa25e02fa2c9939cfeb828f76f86e" title="Saves a complex Eigen dynamic matrix to a MATLAB .mat file,. ">qpp::saveMATLAB()</a></dd></dl>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic double matrix</span></div><div class="line"><span class="comment">// from the MATLAB file &quot;input.mat&quot;</span></div><div class="line"><a class="code" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> mat = loadMATLAB&lt;dmat&gt;(<span class="stringliteral">&quot;input.mat&quot;</span>);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Non-complex Eigen type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen dynamic matrix </dd></dl>

</div>
</div>
<a id="a95a129545b05e69dd7f4c60b009ca183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a129545b05e69dd7f4c60b009ca183">&#9670;&nbsp;</a></span>logdet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::logdet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithm of the determinant. </p>
<p>Useful when the determinant overflows/underflows</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithm of the determinant of <em>A</em>, as a scalar over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a683ff6f7df206be1a6105317c4c8ed70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683ff6f7df206be1a6105317c4c8ed70">&#9670;&nbsp;</a></span>logm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::logm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix logarithm of <em>A</em> </dd></dl>

</div>
</div>
<a id="a825e4812d1b111b04bc3744e4abc1246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825e4812d1b111b04bc3744e4abc1246">&#9670;&nbsp;</a></span>lognegativity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::lognegativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithmic negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithmic negativity, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="a9a907dae004630131cc42354dfd66b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a907dae004630131cc42354dfd66b98">&#9670;&nbsp;</a></span>lognegativity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::lognegativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithmic negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithmic negativity, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="a6231fc8c64c2d14bb701eb783d9d1e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6231fc8c64c2d14bb701eb783d9d1e3a">&#9670;&nbsp;</a></span>marginalX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::marginalX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;&#160;</td>
          <td class="paramname"><em>probXY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marginal distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probXY</td><td>Real matrix representing the joint probability distribution of <em>X</em> and <em>Y</em> in lexicographical order (<em>X</em> labels the rows, <em>Y</em> labels the columns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the marginal distribution of <em>X</em> </dd></dl>

</div>
</div>
<a id="a7a770cae0d7a05ca4590dec72390ebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a770cae0d7a05ca4590dec72390ebc7">&#9670;&nbsp;</a></span>marginalY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::marginalY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> &amp;&#160;</td>
          <td class="paramname"><em>probXY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marginal distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probXY</td><td>Real matrix representing the joint probability distribution of <em>X</em> and <em>Y</em> in lexicographical order (<em>X</em> labels the rows, <em>Y</em> labels the columns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the marginal distribution of <em>Y</em> </dd></dl>

</div>
</div>
<a id="a65da96cadec88fbbb3cc70b0a82fa90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65da96cadec88fbbb3cc70b0a82fa90c">&#9670;&nbsp;</a></span>measure() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="a943b1da665384d3076f7118771783e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943b1da665384d3076f7118771783e84">&#9670;&nbsp;</a></span>measure() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="a0dcb1c411953ecda5ed943c7afec47c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcb1c411953ecda5ed943c7afec47c4">&#9670;&nbsp;</a></span>measure() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">U</td><td>Unitary matrix whose columns represent the measurement basis vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="afc560cc8d11fa4464bc0872e167b6ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc560cc8d11fa4464bc0872e167b6ef3">&#9670;&nbsp;</a></span>measure() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651" title="Sequentially measures the part subsys of the multi-partite state vector or density matrix A in the co...">qpp::measure_seq()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>. The measurement is destructive, i.e. the measured subsystems are traced away.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="a3b026b0c869a4b789f25e82062ecf875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b026b0c869a4b789f25e82062ecf875">&#9670;&nbsp;</a></span>measure() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651" title="Sequentially measures the part subsys of the multi-partite state vector or density matrix A in the co...">qpp::measure_seq()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>. The measurement is destructive, i.e. the measured subsystems are traced away.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="a5ae883fc70a9e90e3a2d3e55bd79afdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae883fc70a9e90e3a2d3e55bd79afdc">&#9670;&nbsp;</a></span>measure() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651" title="Sequentially measures the part subsys of the multi-partite state vector or density matrix A in the co...">qpp::measure_seq()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>. The measurement is destructive, i.e. the measured subsystems are traced away.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="a10244fe2afb77153b3a1d33e5bd3576a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10244fe2afb77153b3a1d33e5bd3576a">&#9670;&nbsp;</a></span>measure() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651" title="Sequentially measures the part subsys of the multi-partite state vector or density matrix A in the co...">qpp::measure_seq()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>. The measurement is destructive, i.e. the measured subsystems are traced away.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="aaa693d26c5d066161a0dbf66f6ebb711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa693d26c5d066161a0dbf66f6ebb711">&#9670;&nbsp;</a></span>measure() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the orthonormal basis or rank-1 POVM specified by the matrix <em>V</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651" title="Sequentially measures the part subsys of the multi-partite state vector or density matrix A in the co...">qpp::measure_seq()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of <em>V</em> must match the dimension of <em>subsys</em>. The measurement is destructive, i.e. the measured subsystems are traced away.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">V</td><td>Matrix whose columns represent the measurement basis vectors or the bra parts of the rank-1 POVM </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="a9c01499b1db74022e6f4d8d5e730f800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c01499b1db74022e6f4d8d5e730f800">&#9670;&nbsp;</a></span>measure() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the orthonormal basis or rank-1 POVM specified by the matrix <em>V</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aa711cc3f139002a0954b612a57409651" title="Sequentially measures the part subsys of the multi-partite state vector or density matrix A in the co...">qpp::measure_seq()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The dimension of <em>V</em> must match the dimension of <em>subsys</em>. The measurement is destructive, i.e. the measured subsystems are traced away.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">V</td><td>Matrix whose columns represent the measurement basis vectors or the bra parts of the rank-1 POVM </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Result of the measurement, 2. Vector of outcome probabilities, and 3. Vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a id="aa711cc3f139002a0954b612a57409651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa711cc3f139002a0954b612a57409651">&#9670;&nbsp;</a></span>measure_seq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt;, double, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::measure_seq </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequentially measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the computational basis. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a65da96cadec88fbbb3cc70b0a82fa90c" title="Measures the state A using the set of Kraus operators Ks. ">qpp::measure()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Vector of outcome results of the measurement (ordered in increasing order with respect to <em>subsys</em>, i.e. first measurement result corresponds to the subsystem with the smallest index), 2. Outcome probability, and 3. Post-measurement normalized state </dd></dl>

</div>
</div>
<a id="a49fc09ba403372739d5a1f6105ef973f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fc09ba403372739d5a1f6105ef973f">&#9670;&nbsp;</a></span>measure_seq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt;, double, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::measure_seq </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequentially measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> in the computational basis. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a65da96cadec88fbbb3cc70b0a82fa90c" title="Measures the state A using the set of Kraus operators Ks. ">qpp::measure()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Vector of outcome results of the measurement (ordered in increasing order with respect to <em>subsys</em>, i.e. first measurement result corresponds to the subsystem with the smallest index), 2. Outcome probability, and 3. Post-measurement normalized state </dd></dl>

</div>
</div>
<a id="a2f09ed5c440772b552a289b800d4415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f09ed5c440772b552a289b800d4415a">&#9670;&nbsp;</a></span>mket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a> qpp::mket </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi-partite qudit ket. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea" title="Complex (double precision) dynamic Eigen column vector. ">ket</a> template&lt;char... Bits&gt; <a class="el" href="namespaceqpp_1_1literals.html#af1b1b403462748ca5a55c10e8e41d80d" title="Multi-partite qubit ket user-defined literal. ">qpp::operator "" _ket()</a></dd></dl>
<p>Constructs the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_37.png"/>, where <em>mask</em> is a std::vector of non-negative integers. Each element in <em>mask</em> has to be smaller than the corresponding element in <em>dims</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-partite qudit state vector, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a id="a3d054252433fbf793575092697f9d985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d054252433fbf793575092697f9d985">&#9670;&nbsp;</a></span>mket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a> qpp::mket </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi-partite qudit ket. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea" title="Complex (double precision) dynamic Eigen column vector. ">ket</a> template&lt;char... Bits&gt; <a class="el" href="namespaceqpp_1_1literals.html#af1b1b403462748ca5a55c10e8e41d80d" title="Multi-partite qubit ket user-defined literal. ">qpp::operator "" _ket()</a></dd></dl>
<p>Constructs the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_37.png"/>, all subsystem having equal dimension <em>d</em>. <em>mask</em> is a std::vector of non-negative integers, and each element in <em>mask</em> has to be strictly smaller than <em>d</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-partite qudit state vector, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a id="a7e53beed2f6bb8d374ac2e2460aee2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e53beed2f6bb8d374ac2e2460aee2c2">&#9670;&nbsp;</a></span>modinv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::modinv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modular inverse of <em>a</em> mod <em>p</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a0d115963145ca884c5d9ef8f3b18bf83" title="Extended greatest common divisor of two integers. ">qpp::egcd()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>a</em> and <em>p</em> must be co-prime</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Non-negative integer </td></tr>
    <tr><td class="paramname">p</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Modular inverse <img class="formulaInl" alt="$a^{-1}$" src="form_53.png"/> <img class="formulaInl" alt="$\textrm{ mod }$" src="form_54.png"/> <img class="formulaInl" alt="$p$" src="form_47.png"/> </dd></dl>

</div>
</div>
<a id="affc15bf57e2a45f720b0f49034c22827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc15bf57e2a45f720b0f49034c22827">&#9670;&nbsp;</a></span>modmul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::modmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modular multiplication without overflow. </p>
<p>Computes <img class="formulaInl" alt="$ab$" src="form_45.png"/> <img class="formulaInl" alt="$\mathrm{ mod }$" src="form_46.png"/> <img class="formulaInl" alt="$p$" src="form_47.png"/> without overflow</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer </td></tr>
    <tr><td class="paramname">b</td><td>Integer </td></tr>
    <tr><td class="paramname">p</td><td>Positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ab$" src="form_45.png"/> <img class="formulaInl" alt="$\mathrm{ mod }$" src="form_46.png"/> <img class="formulaInl" alt="$p$" src="form_47.png"/> avoiding overflow </dd></dl>

</div>
</div>
<a id="a0ff25c25c0ff9304255495eb90b98d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff25c25c0ff9304255495eb90b98d1b">&#9670;&nbsp;</a></span>modpow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::modpow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast integer power modulo <em>p</em> based on the SQUARE-AND-MULTIPLY algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>Uses <a class="el" href="namespaceqpp.html#affc15bf57e2a45f720b0f49034c22827" title="Modular multiplication without overflow. ">qpp::modmul()</a> that avoids overflows</dd></dl>
<p>Computes <img class="formulaInl" alt="$a^n$" src="form_48.png"/> <img class="formulaInl" alt="$\mathrm{ mod }$" src="form_46.png"/> <img class="formulaInl" alt="$p$" src="form_47.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Non-negative integer </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
    <tr><td class="paramname">p</td><td>Strictly positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$a^n$" src="form_48.png"/> <img class="formulaInl" alt="$\mathrm{ mod }$" src="form_46.png"/> <img class="formulaInl" alt="$p$" src="form_47.png"/> </dd></dl>

</div>
</div>
<a id="a3ee4bf8befeea8079ad61c7070ba9fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee4bf8befeea8079ad61c7070ba9fa2">&#9670;&nbsp;</a></span>mprj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::mprj </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projector onto multi-partite qudit ket. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">cmat</a> template&lt;char... Bits&gt; <a class="el" href="namespaceqpp_1_1literals.html#a807ed54ce7598a383aa383d1cb60436a" title="Multi-partite qubit projector user-defined literal. ">qpp::operator "" _prj()</a></dd></dl>
<p>Constructs the projector onto the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_37.png"/>, where <em>mask</em> is a std::vector of non-negative integers. Each element in <em>mask</em> has to be smaller than the corresponding element in <em>dims</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto multi-partite qudit state vector, as a complex dynamic matrix </dd></dl>

</div>
</div>
<a id="a7a4e06590399ad3a7b4a15ba62849e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4e06590399ad3a7b4a15ba62849e82">&#9670;&nbsp;</a></span>mprj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::mprj </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projector onto multi-partite qudit ket. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">cmat</a> template&lt;char... Bits&gt; <a class="el" href="namespaceqpp_1_1literals.html#a807ed54ce7598a383aa383d1cb60436a" title="Multi-partite qubit projector user-defined literal. ">qpp::operator "" _prj()</a></dd></dl>
<p>Constructs the projector onto the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_37.png"/>, all subsystem having equal dimension <em>d</em>. <em>mask</em> is a std::vector of non-negative integers, and each element in <em>mask</em> has to be strictly smaller than <em>d</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto multi-partite qudit state vector, as a complex dynamic matrix </dd></dl>

</div>
</div>
<a id="a9f0ce02aa3e299e610cf5f7715c1a43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0ce02aa3e299e610cf5f7715c1a43f">&#9670;&nbsp;</a></span>multiidx2n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> qpp::multiidx2n </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>midx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multi-index to non-negative integer index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a5c6a9fc4e463ff3397ced98bc9df0a1c" title="Non-negative integer index to multi-index. ">qpp::n2multiidx()</a></dd></dl>
<p>Uses standard lexicographical order, i.e. 00...0, 00...1 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">midx</td><td>Multi-index </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative integer index </dd></dl>

</div>
</div>
<a id="a5c6a9fc4e463ff3397ced98bc9df0a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6a9fc4e463ff3397ced98bc9df0a1c">&#9670;&nbsp;</a></span>n2multiidx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt; qpp::n2multiidx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-negative integer index to multi-index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a9f0ce02aa3e299e610cf5f7715c1a43f" title="Multi-index to non-negative integer index. ">qpp::multiidx2n()</a></dd></dl>
<p>Uses standard lexicographical order, i.e. 00...0, 00...1 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Non-negative integer index </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-index of the same size as <em>dims</em> </dd></dl>

</div>
</div>
<a id="a7e79a2383dc47a848ea3e88337070e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e79a2383dc47a848ea3e88337070e62">&#9670;&nbsp;</a></span>negativity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::negativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negativity </dd></dl>

</div>
</div>
<a id="aa5d9417d9ab61f2f78b0c4b3d8bc0674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d9417d9ab61f2f78b0c4b3d8bc0674">&#9670;&nbsp;</a></span>negativity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::negativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negativity </dd></dl>

</div>
</div>
<a id="af2e4740854c958579228593dd639aa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e4740854c958579228593dd639aa6c">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frobenius norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frobenius norm of <em>A</em> </dd></dl>

</div>
</div>
<a id="a621afdaae12a94a5e10a874fc2073dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621afdaae12a94a5e10a874fc2073dc0">&#9670;&nbsp;</a></span>omega()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> qpp::omega </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>D-th root of unity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>D-th root of unity <img class="formulaInl" alt="$\exp(2\pi i/D)$" src="form_14.png"/> </dd></dl>

</div>
</div>
<a id="a12e22073e741a1057129fa01b4ec10a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e22073e741a1057129fa01b4ec10a6">&#9670;&nbsp;</a></span>operator"" _i()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> qpp::operator&quot;&quot; _i </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_11.png"/> (real overload) </p>
<p>Example:</p><div class="fragment"><div class="line"><a class="code" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z = 4.5_i; <span class="comment">// type of z is std::complex&lt;double&gt; </span></div></div><!-- fragment --> 
</div>
</div>
<a id="adc34b7cd0bcbdddf99c4835489c47b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc34b7cd0bcbdddf99c4835489c47b5d">&#9670;&nbsp;</a></span>powm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::powm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast matrix power based on the SQUARE-AND-MULTIPLY algorithm. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a62d7f0db6a049f254c2a7a77af8eb29e" title="Matrix power. ">qpp::spectralpowm()</a></dd></dl>
<p>Explicitly multiplies the matrix <em>A</em> with itself <em>n</em> times. By convention <img class="formulaInl" alt="$A^0 = I$" src="form_27.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix power <img class="formulaInl" alt="$A^n$" src="form_29.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a13b51403e1cb33d8c1f7678eb8aae42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b51403e1cb33d8c1f7678eb8aae42c">&#9670;&nbsp;</a></span>prj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::prj </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector. </p>
<p>Normalized projector onto state vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto the state vector <em>A</em>, or the matrix <em>Zero</em> if <em>A</em> has norm zero (i.e. smaller than <a class="el" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6" title="Used to decide whether a number or expression in double precision is zero or not. ...">qpp::eps</a>), as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a78595ec429a5df51dbe682cdb9711d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78595ec429a5df51dbe682cdb9711d9c">&#9670;&nbsp;</a></span>prod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::prod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of <em>A</em>, as a scalar over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a7f4d7011145e0589b6ba5767dcf90885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4d7011145e0589b6ba5767dcf90885">&#9670;&nbsp;</a></span>prod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::value_type qpp::prod </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of an STL-like range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of the range, as a scalar over the same scalar field as the range </dd></dl>

</div>
</div>
<a id="aa4e14900b6eb348ef350c455f1110327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e14900b6eb348ef350c455f1110327">&#9670;&nbsp;</a></span>prod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container::value_type qpp::prod </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of the elements of an STL-like container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of the elements of the container, as a scalar over the same scalar field as the container </dd></dl>

</div>
</div>
<a id="a1300526d686af7fec966d8760087a168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1300526d686af7fec966d8760087a168">&#9670;&nbsp;</a></span>ptrace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a3e1f6add4257e7a92af4378a848110b7" title="Partial trace. ">qpp::ptrace1()</a>, <a class="el" href="namespaceqpp.html#a9c0652daea1cfc2385239956ca80b356" title="Partial trace. ">qpp::ptrace2()</a></dd></dl>
<p>Partial trace of the multi-partite state vector or density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{subsys}(\cdot)$" src="form_69.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="ab30f9afcc0a3a5bacb04cb2a8a675743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30f9afcc0a3a5bacb04cb2a8a675743">&#9670;&nbsp;</a></span>ptrace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a3e1f6add4257e7a92af4378a848110b7" title="Partial trace. ">qpp::ptrace1()</a>, <a class="el" href="namespaceqpp.html#a9c0652daea1cfc2385239956ca80b356" title="Partial trace. ">qpp::ptrace2()</a></dd></dl>
<p>Partial trace of the multi-partite state vector or density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{subsys}(\cdot)$" src="form_69.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a3e1f6add4257e7a92af4378a848110b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1f6add4257e7a92af4378a848110b7">&#9670;&nbsp;</a></span>ptrace1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a9c0652daea1cfc2385239956ca80b356" title="Partial trace. ">qpp::ptrace2()</a></dd></dl>
<p>Partial trace over the first subsystem of bi-partite state vector or density matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{A}(\cdot)$" src="form_64.png"/> over the first subsytem <img class="formulaInl" alt="$A$" src="form_65.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_66.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a435a02748cdfe4077d12cb743b0a3cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435a02748cdfe4077d12cb743b0a3cd1">&#9670;&nbsp;</a></span>ptrace1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a9c0652daea1cfc2385239956ca80b356" title="Partial trace. ">qpp::ptrace2()</a></dd></dl>
<p>Partial trace over the first subsystem of bi-partite state vector or density matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{A}(\cdot)$" src="form_64.png"/> over the first subsytem <img class="formulaInl" alt="$A$" src="form_65.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_66.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a9c0652daea1cfc2385239956ca80b356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0652daea1cfc2385239956ca80b356">&#9670;&nbsp;</a></span>ptrace2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a3e1f6add4257e7a92af4378a848110b7" title="Partial trace. ">qpp::ptrace1()</a></dd></dl>
<p>Partial trace over the second subsystem of bi-partite state vector or density matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{B}(\cdot)$" src="form_67.png"/> over the second subsytem <img class="formulaInl" alt="$B$" src="form_68.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_66.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a0e59c0f704c3fde8bb8c4fae5cd3cce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e59c0f704c3fde8bb8c4fae5cd3cce7">&#9670;&nbsp;</a></span>ptrace2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a3e1f6add4257e7a92af4378a848110b7" title="Partial trace. ">qpp::ptrace1()</a></dd></dl>
<p>Partial trace over the second subsystem of bi-partite state vector or density matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{B}(\cdot)$" src="form_67.png"/> over the second subsytem <img class="formulaInl" alt="$B$" src="form_68.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_66.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a97eda566cbbf3baaf8d897d5d49fb5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97eda566cbbf3baaf8d897d5d49fb5f1">&#9670;&nbsp;</a></span>ptranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial transpose. </p>
<p>Partial transpose of the multi-partite state vector or density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial transpose <img class="formulaInl" alt="$(\cdot)^{T_{subsys}}$" src="form_70.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="aaa62e91772d192f1a7981f651ff9072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa62e91772d192f1a7981f651ff9072c">&#9670;&nbsp;</a></span>ptranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::ptranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial transpose. </p>
<p>Partial transpose of the multi-partite state vector or density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial transpose <img class="formulaInl" alt="$(\cdot)^{T_{subsys}}$" src="form_70.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a336521e1a561be170d44dd5a1bc81c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336521e1a561be170d44dd5a1bc81c1d">&#9670;&nbsp;</a></span>qmutualinfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::qmutualinfo </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantum mutual information between 2 subsystems of a composite system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsysA</td><td>Indexes of the first subsystem </td></tr>
    <tr><td class="paramname">subsysB</td><td>Indexes of the second subsystem </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutual information between the 2 subsystems </dd></dl>

</div>
</div>
<a id="a1dfb291551237e2a5b45e335141e759a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfb291551237e2a5b45e335141e759a">&#9670;&nbsp;</a></span>qmutualinfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::qmutualinfo </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantum mutual information between 2 subsystems of a composite system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsysA</td><td>Indexes of the first subsystem </td></tr>
    <tr><td class="paramname">subsysB</td><td>Indexes of the second subsystem </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutual information between the 2 subsystems </dd></dl>

</div>
</div>
<a id="a2f1ee80e9136dc4c16d964b45d7e188d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1ee80e9136dc4c16d964b45d7e188d">&#9670;&nbsp;</a></span>rand() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::rand </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real number uniformly distributed in the interval [a, b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real number (double) uniformly distributed in the interval [a, b) </dd></dl>

</div>
</div>
<a id="ae5647999b1ea7fb98e2fa7cb2f1a59af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5647999b1ea7fb98e2fa7cb2f1a59af">&#9670;&nbsp;</a></span>rand() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random big integer uniformly distributed in the interval [a, b]. </p>
<dl class="section note"><dt>Note</dt><dd>To avoid ambiguity with double <a class="el" href="namespaceqpp.html#a2f1ee80e9136dc4c16d964b45d7e188d" title="Generates a random real number uniformly distributed in the interval [a, b) ">qpp::rand(double, double)</a> cast at least one of the arguments to <a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949" title="Big integer. ">qpp::bigint</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, belongs to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random big integer uniformly distributed in the interval [a, b] </dd></dl>

</div>
</div>
<a id="a6e4bd67e5334b4a9ac09216e8fe37249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4bd67e5334b4a9ac09216e8fe37249">&#9670;&nbsp;</a></span>rand() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random matrix with entries uniformly distributed in the interval [a, b) </p>
<p>If complex, then both real and imaginary parts are uniformly distributed in [a, b)</p>
<p>This is the generic version that always throws qpp::Exception::Type::UNDEFINED_TYPE. It is specialized only for <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a> and <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a> </p>

</div>
</div>
<a id="a884c04674e908e0ee6160a8d37623766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884c04674e908e0ee6160a8d37623766">&#9670;&nbsp;</a></span>rand() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real matrix with entries uniformly distributed in the interval [a, b), specialization for double matrices (<a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXd,</span></div><div class="line"><span class="comment">// with entries uniformly distributed in [-1,1)</span></div><div class="line"><a class="code" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> mat = rand&lt;dmat&gt;(3, 3, -1, 1);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real matrix </dd></dl>

</div>
</div>
<a id="a2a6ed04b1092ce25ceed3ce4e7136b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6ed04b1092ce25ceed3ce4e7136b48">&#9670;&nbsp;</a></span>rand() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random complex matrix with entries (both real and imaginary) uniformly distributed in the interval [a, b), specialization for complex matrices (<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXcd,</span></div><div class="line"><span class="comment">// with entries (both real and imaginary) uniformly distributed in [-1,1)</span></div><div class="line"><a class="code" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> mat = rand&lt;cmat&gt;(3, 3, -1, 1);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random complex matrix </dd></dl>

</div>
</div>
<a id="afaeabb6405223cf7cd2b0084dc141ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaeabb6405223cf7cd2b0084dc141ec3">&#9670;&nbsp;</a></span>randH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::randH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>D</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random Hermitian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random Hermitian matrix </dd></dl>

</div>
</div>
<a id="ab2e295b33fd56735f0bffb21d61d21dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e295b33fd56735f0bffb21d61d21dd">&#9670;&nbsp;</a></span>randidx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> qpp::randidx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>a</em> = <code>std::numeric_limits&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt;::min()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>b</em> = <code>std::numeric_limits&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random index (idx) uniformly distributed in the interval [a, b]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, belongs to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random index (idx) uniformly distributed in the interval [a, b] </dd></dl>

</div>
</div>
<a id="a9d9ba9e2566a16832dac2b7ea388a1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9ba9e2566a16832dac2b7ea388a1b1">&#9670;&nbsp;</a></span>randket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a5d7185dfc7bee58c937abc243c3692ea">ket</a> qpp::randket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>D</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random normalized ket (pure state vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random normalized ket </dd></dl>

</div>
</div>
<a id="a2b62ef049b9e0d0109d54c0c45683498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b62ef049b9e0d0109d54c0c45683498">&#9670;&nbsp;</a></span>randkraus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::randkraus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>D</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a set of random Kraus operators. </p>
<dl class="section note"><dt>Note</dt><dd>The set of Kraus operators satisfy the closure condition <img class="formulaInl" alt="$ \sum_i K_i^\dagger K_i = I$" src="form_71.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of Kraus operators </td></tr>
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of <em>N</em> Kraus operators satisfying the closure condition </dd></dl>

</div>
</div>
<a id="aeeb9fb000b5bb9056653c3d2c10a1d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb9fb000b5bb9056653c3d2c10a1d65">&#9670;&nbsp;</a></span>randn() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::randn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random matrix with entries normally distributed in N(mean, sigma) </p>
<p>If complex, then both real and imaginary parts are normally distributed in N(mean, sigma)</p>
<p>This is the generic version that always throws qpp::Exception::Type::UNDEFINED_TYPE. It is specialized only for <a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a> and <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a> </p>

</div>
</div>
<a id="a793a175c6092603d8d4518ede7176fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793a175c6092603d8d4518ede7176fce">&#9670;&nbsp;</a></span>randn() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> qpp::randn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real matrix with entries normally distributed in N(mean, sigma), specialization for double matrices (<a class="el" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXd,</span></div><div class="line"><span class="comment">// with entries normally distributed in N(0,2)</span></div><div class="line"><a class="code" href="namespaceqpp.html#a923e2becc99eb818c04c71ae913902ff">dmat</a> mat = randn&lt;dmat&gt;(3, 3, 0, 2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real matrix </dd></dl>

</div>
</div>
<a id="a97b7474e691f0a85940ef6265645a716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b7474e691f0a85940ef6265645a716">&#9670;&nbsp;</a></span>randn() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::randn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random complex matrix with entries (both real and imaginary) normally distributed in N(mean, sigma), specialization for complex matrices (<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXcd,</span></div><div class="line"><span class="comment">// with entries (both real and imaginary) normally distributed in N(0,2)</span></div><div class="line"><a class="code" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> mat = randn&lt;cmat&gt;(3, 3, 0, 2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random complex matrix </dd></dl>

</div>
</div>
<a id="ab967280114b9e2003bd559c840a5f0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab967280114b9e2003bd559c840a5f0e6">&#9670;&nbsp;</a></span>randn() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::randn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real number (double) normally distributed in N(mean, sigma) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real number normally distributed in N(mean, sigma) </dd></dl>

</div>
</div>
<a id="a34aa968f8779cff8a973798557f38bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34aa968f8779cff8a973798557f38bc3">&#9670;&nbsp;</a></span>randperm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&gt; qpp::randperm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random uniformly distributed permutation. </p>
<p>Uses Knuth shuffle method (as implemented by std::shuffle), so that all permutations are equally probable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Size of the permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random permutation of size <em>N</em> </dd></dl>

</div>
</div>
<a id="ac7a4e9b856bf9a858b71c536acbbab39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a4e9b856bf9a858b71c536acbbab39">&#9670;&nbsp;</a></span>randprime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a> qpp::randprime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#ad199ade0836f0d8488e7f6c7c8aa1949">bigint</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random big prime uniformly distributed in the interval [a, b]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, belongs to it </td></tr>
    <tr><td class="paramname">N</td><td>Maximum number of candidates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random big integer uniformly distributed in the interval [a, b] </dd></dl>

</div>
</div>
<a id="a80909feea5c4e3ab6fbf5394f9485a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80909feea5c4e3ab6fbf5394f9485a1f">&#9670;&nbsp;</a></span>randprob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::randprob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random probability vector uniformly distributed over the probability simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Size of the probability vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random probability vector </dd></dl>

</div>
</div>
<a id="a179bc0022d2b0365d8d7bd0b7767a4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179bc0022d2b0365d8d7bd0b7767a4db">&#9670;&nbsp;</a></span>randrho()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::randrho </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>D</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random density matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random density matrix </dd></dl>

</div>
</div>
<a id="a5bbd539cb9973433e650a86b0f42d2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbd539cb9973433e650a86b0f42d2f4">&#9670;&nbsp;</a></span>randU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::randU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>D</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random unitary matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random unitary </dd></dl>

</div>
</div>
<a id="a7e4eff328bfb8e86da723c6659052d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4eff328bfb8e86da723c6659052d90">&#9670;&nbsp;</a></span>randV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::randV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>Din</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>Dout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random isometry matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Din</td><td>Size of the input Hilbert space </td></tr>
    <tr><td class="paramname">Dout</td><td>Size of the output Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random isometry matrix </dd></dl>

</div>
</div>
<a id="a991bc6df4280943452bfbedafa65b9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991bc6df4280943452bfbedafa65b9f7">&#9670;&nbsp;</a></span>renyi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::renyi </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_17.png"/> entropy of the density matrix <em>A</em>, for <img class="formulaInl" alt="$\alpha\geq 0$" src="form_18.png"/>. </p>
<dl class="section note"><dt>Note</dt><dd>When <img class="formulaInl" alt="$ \alpha\to 1$" src="form_19.png"/> the Renyi entropy converges to the von-Neumann entropy, with the logarithm in base 2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">alpha</td><td>Non-negative real number, use <a class="el" href="namespaceqpp.html#aecd9c0f42f21f1d3b29868b6a8cac4c7" title="Used to denote infinity in double precision. ">qpp::infty</a> for <img class="formulaInl" alt="$\alpha = \infty$" src="form_20.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_17.png"/> entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="ae0268f55bb9b2fdd0495d8b67f74f6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0268f55bb9b2fdd0495d8b67f74f6e3">&#9670;&nbsp;</a></span>renyi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::renyi </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_17.png"/> entropy of the probability distribution <em>prob</em>, for <img class="formulaInl" alt="$\alpha\geq 0$" src="form_18.png"/>. </p>
<dl class="section note"><dt>Note</dt><dd>When <img class="formulaInl" alt="$ \alpha\to 1$" src="form_19.png"/> the Renyi entropy converges to the Shannon entropy, with the logarithm in base 2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>Real probability vector </td></tr>
    <tr><td class="paramname">alpha</td><td>Non-negative real number, use <a class="el" href="namespaceqpp.html#aecd9c0f42f21f1d3b29868b6a8cac4c7" title="Used to denote infinity in double precision. ">qpp::infty</a> for <img class="formulaInl" alt="$\alpha = \infty$" src="form_20.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_17.png"/> entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a id="afa33bacb26cad466156dc3f8f3980da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa33bacb26cad466156dc3f8f3980da7">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::reshape </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshape. </p>
<p>Uses column-major order when reshaping (same as MATLAB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows of the reshaped matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the reshaped matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reshaped matrix with <em>rows</em> rows and <em>cols</em> columns, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a2b8b1ec9320981f9b5d6984810f14737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8b1ec9320981f9b5d6984810f14737">&#9670;&nbsp;</a></span>rho2bloch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::rho2bloch </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the 3-dimensional real Bloch vector corresponding to the qubit density matrix <em>A</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a7e5c413d74d838e78264444307e81576" title="Computes the density matrix corresponding to the 3-dimensional real Bloch vector r. ">qpp::bloch2rho()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is implicitly assumed that the density matrix is Hermitian</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3-dimensional Bloch vector </dd></dl>

</div>
</div>
<a id="ad3b0046735db751418aea0b81d0cb048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0046735db751418aea0b81d0cb048">&#9670;&nbsp;</a></span>rho2pure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;typename Derived::Scalar&gt; qpp::rho2pure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the pure state representation of a matrix proportional to a projector onto a pure state. </p>
<dl class="section note"><dt>Note</dt><dd>No purity check is done, the input state <em>A</em> must have rank one, otherwise the function returns the first non-zero eigenvector of <em>A</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, assumed to be proportional to a projector onto a pure state, i.e. <em>A</em> is assumed to have rank one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique non-zero eigenvector of <em>A</em> (up to a phase), as a dynamic column vector over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a238cf516513837235fbc7d7d283f7b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238cf516513837235fbc7d7d283f7b78">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qpp::save </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves Eigen expression to a binary file (internal format) in double precision. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#aea6b39f40a9c9a188a5e0dd244b4bf08" title="Loads Eigen matrix from a binary file (internal format) in double precision. ">qpp::load()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">fname</td><td>Output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37dfa25e02fa2c9939cfeb828f76f86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dfa25e02fa2c9939cfeb828f76f86e">&#9670;&nbsp;</a></span>saveMATLAB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;::value&gt;::type qpp::saveMATLAB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a complex Eigen dynamic matrix to a MATLAB .mat file,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a624018095ea24ab31e6a9d93c33b3aa2" title="Loads a complex Eigen dynamic matrix from a MATLAB .mat file,. ">qpp::loadMATLAB()</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Complex</td><td>Eigen type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression over the complex field </td></tr>
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be saved </td></tr>
    <tr><td class="paramname">mode</td><td>Saving mode (append, overwrite etc.), see MATLAB <em>matOpen()</em> documentation for details </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d15195b80026f19f9f72fdead71d3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d15195b80026f19f9f72fdead71d3f5">&#9670;&nbsp;</a></span>saveMATLAB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt;typename Derived::Scalar, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;::value&gt;::type qpp::saveMATLAB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a non-complex Eigen dynamic matrix to a MATLAB .mat file,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a624018095ea24ab31e6a9d93c33b3aa2" title="Loads a complex Eigen dynamic matrix from a MATLAB .mat file,. ">qpp::loadMATLAB()</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Npn-complex</td><td>Eigen type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Non-complex Eigen expression </td></tr>
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be saved </td></tr>
    <tr><td class="paramname">mode</td><td>Saving mode (append, overwrite etc.), see MATLAB <em>matOpen()</em> documentation for details </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1865cddc66aa88d853512abd39e584e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1865cddc66aa88d853512abd39e584e1">&#9670;&nbsp;</a></span>schatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::schatten </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schatten matrix norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">p</td><td>Real number, greater or equal to 1, use <a class="el" href="namespaceqpp.html#aecd9c0f42f21f1d3b29868b6a8cac4c7" title="Used to denote infinity in double precision. ">qpp::infty</a> for <img class="formulaInl" alt="$p = \infty$" src="form_30.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schatten-<em>p</em> matrix norm of <em>A</em> </dd></dl>

</div>
</div>
<a id="a27d0cd12502123ea1fe7c48d1043439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d0cd12502123ea1fe7c48d1043439a">&#9670;&nbsp;</a></span>schmidtA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::schmidtA </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Alice side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ U $" src="form_15.png"/> whose columns represent the Schmidt basis vectors on Alice side. </dd></dl>

</div>
</div>
<a id="ad812c56e195e8203d1be92c78837ed70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad812c56e195e8203d1be92c78837ed70">&#9670;&nbsp;</a></span>schmidtA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::schmidtA </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Alice side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ U $" src="form_15.png"/> whose columns represent the Schmidt basis vectors on Alice side. </dd></dl>

</div>
</div>
<a id="a9843ae59cf424139b3537d21fbfd5860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9843ae59cf424139b3537d21fbfd5860">&#9670;&nbsp;</a></span>schmidtB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::schmidtB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Bob side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ V $" src="form_16.png"/> whose columns represent the Schmidt basis vectors on Bob side. </dd></dl>

</div>
</div>
<a id="a3b86cd008bbcf7c8bc3dd1d990225fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b86cd008bbcf7c8bc3dd1d990225fdb">&#9670;&nbsp;</a></span>schmidtB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::schmidtB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Bob side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ V $" src="form_16.png"/> whose columns represent the Schmidt basis vectors on Bob side. </dd></dl>

</div>
</div>
<a id="a643a3f3073b38757ad670ad3d0c64850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643a3f3073b38757ad670ad3d0c64850">&#9670;&nbsp;</a></span>schmidtcoeffs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;double&gt; qpp::schmidtcoeffs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt coefficients of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The sum of the squares of the Schmidt coefficients equals 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a61ff269f163f35f9e929ca800fe8b32f" title="Schmidt probabilities of the bi-partite pure state A. ">qpp::schmidtprobs()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schmidt coefficients of <em>A</em>, ordered in decreasing order, as a real dynamic column vector </dd></dl>

</div>
</div>
<a id="ac8577e76402408ffb229dd821e826a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8577e76402408ffb229dd821e826a08">&#9670;&nbsp;</a></span>schmidtcoeffs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;double&gt; qpp::schmidtcoeffs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt coefficients of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The sum of the squares of the Schmidt coefficients equals 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a61ff269f163f35f9e929ca800fe8b32f" title="Schmidt probabilities of the bi-partite pure state A. ">qpp::schmidtprobs()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schmidt coefficients of <em>A</em>, ordered in decreasing order, as a real dynamic column vector </dd></dl>

</div>
</div>
<a id="a61ff269f163f35f9e929ca800fe8b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ff269f163f35f9e929ca800fe8b32f">&#9670;&nbsp;</a></span>schmidtprobs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::schmidtprobs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt probabilities of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the squares of the Schmidt coefficients. The sum of the Schmidt probabilities equals 1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a643a3f3073b38757ad670ad3d0c64850" title="Schmidt coefficients of the bi-partite pure state A. ">qpp::schmidtcoeffs()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the Schmidt probabilites of <em>A</em>, ordered in decreasing order </dd></dl>

</div>
</div>
<a id="a15e71427121f407c51cbb0bfe0f3f0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e71427121f407c51cbb0bfe0f3f0a0">&#9670;&nbsp;</a></span>schmidtprobs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::schmidtprobs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt probabilities of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the squares of the Schmidt coefficients. The sum of the Schmidt probabilities equals 1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a643a3f3073b38757ad670ad3d0c64850" title="Schmidt coefficients of the bi-partite pure state A. ">qpp::schmidtcoeffs()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the Schmidt probabilites of <em>A</em>, ordered in decreasing order </dd></dl>

</div>
</div>
<a id="a5dac002761cbcfb72cdb6a573e2689c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dac002761cbcfb72cdb6a573e2689c3">&#9670;&nbsp;</a></span>sigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::sigma </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>Real probability vector representing the probability distribution of <em>X</em> </td></tr>
    <tr><td class="paramname">X</td><td>Real random variable values represented by an STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard deviation of <em>X</em> </dd></dl>

</div>
</div>
<a id="a78be6e812878479d6acbd25cf5ae387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78be6e812878479d6acbd25cf5ae387c">&#9670;&nbsp;</a></span>sinm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::sinm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix sine of <em>A</em> </dd></dl>

</div>
</div>
<a id="a62d7f0db6a049f254c2a7a77af8eb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d7f0db6a049f254c2a7a77af8eb29e">&#9670;&nbsp;</a></span>spectralpowm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::spectralpowm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix power. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#adc34b7cd0bcbdddf99c4835489c47b5d" title="Fast matrix power based on the SQUARE-AND-MULTIPLY algorithm. ">qpp::powm()</a></dd></dl>
<p>Uses the spectral decomposition of <em>A</em> to compute the matrix power. By convention <img class="formulaInl" alt="$A^0 = I$" src="form_27.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">z</td><td>Complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix power <img class="formulaInl" alt="$A^z$" src="form_28.png"/> </dd></dl>

</div>
</div>
<a id="a83e2b23bc11e3cb8dd6909969af7377c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e2b23bc11e3cb8dd6909969af7377c">&#9670;&nbsp;</a></span>sqrtm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::sqrtm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix square root of <em>A</em> </dd></dl>

</div>
</div>
<a id="a48a92e8a327ff86f87c6236965103797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a92e8a327ff86f87c6236965103797">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of <em>A</em>, as a scalar over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a71fdacbcc8284b5088c582310f9962f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fdacbcc8284b5088c582310f9962f1">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::value_type qpp::sum </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of an STL-like range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of the range, as a scalar over the same scalar field as the range </dd></dl>

</div>
</div>
<a id="a1126bc1c914bda6a04c1c622cddb8afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1126bc1c914bda6a04c1c622cddb8afe">&#9670;&nbsp;</a></span>sum() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container::value_type qpp::sum </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of the elements of an STL-like container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of the elements of the container, as a scalar over the same scalar field as the container </dd></dl>

</div>
</div>
<a id="ad2b8ee9e2f9b51a281f7c42f61571c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b8ee9e2f9b51a281f7c42f61571c9a">&#9670;&nbsp;</a></span>super2choi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::super2choi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts superoperator matrix to Choi matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a8b5fb595977b62ea764f9362828678f2" title="Converts Choi matrix to superoperator matrix. ">qpp::choi2super()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Superoperator matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Choi matrix </dd></dl>

</div>
</div>
<a id="abe012650e8ff95fc346dd75cdbb3625a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe012650e8ff95fc346dd75cdbb3625a">&#9670;&nbsp;</a></span>svals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;double&gt; qpp::svals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Singular values of <em>A</em>, ordered in decreasing order, as a real dynamic column vector </dd></dl>

</div>
</div>
<a id="a01fbc71879953afc92d8828aa6b99627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fbc71879953afc92d8828aa6b99627">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>, <a class="el" href="namespaceqpp.html#a07c62992d1a236f062887990eea26b15">dyn_col_vect</a>&lt;double&gt;, <a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a>&gt; qpp::svd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of: 1. Left sigular vectors of <em>A</em>, as columns of a complex dynamic matrix, 2. Singular values of <em>A</em>, ordered in decreasing order, as a real dynamic column vector, and 3. Right singular vectors of <em>A</em>, as columns of a complex dynamic matrix </dd></dl>

</div>
</div>
<a id="a33c070beade098fa8f26440791cc8840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c070beade098fa8f26440791cc8840">&#9670;&nbsp;</a></span>svdU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::svdU </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left singular vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex dynamic matrix, whose columns are the left singular vectors of <em>A</em> </dd></dl>

</div>
</div>
<a id="a285eda1b8ec8614398dd731e5e3a89ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285eda1b8ec8614398dd731e5e3a89ed">&#9670;&nbsp;</a></span>svdV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ab0de67006716bdc8fae52c6a49259276">cmat</a> qpp::svdV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right singular vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex dynamic matrix, whose columns are the right singular vectors of <em>A</em> </dd></dl>

</div>
</div>
<a id="a4cf8dec8978b57214c806094f69e05ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf8dec8978b57214c806094f69e05ca">&#9670;&nbsp;</a></span>syspermute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::syspermute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subsystem permutation. </p>
<p>Permutes the subsystems of a state vector or density matrix. The qubit <em>perm</em>[<em>i</em>] is permuted to the location <em>i</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Permuted system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="af9de352ae53eb3ad8141721b487869b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9de352ae53eb3ad8141721b487869b0">&#9670;&nbsp;</a></span>syspermute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::syspermute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subsystem permutation. </p>
<p>Permutes the subsystems of a state vector or density matrix. The qubit <em>perm</em>[<em>i</em>] is permuted to the location <em>i</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Permuted system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a1e1daff5450728504da1fdfedf8d8b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1daff5450728504da1fdfedf8d8b54">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::trace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of <em>A</em>, as a scalar over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="a2d40b2372b7537b8a5b9e0a92d729769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d40b2372b7537b8a5b9e0a92d729769">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#ac39e7c2b66f0209911cc3afc06223648">dyn_mat</a>&lt;typename Derived::Scalar&gt; qpp::transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a id="aeff1197fe1e27f2dc5caeb032d80f6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff1197fe1e27f2dc5caeb032d80f6b4">&#9670;&nbsp;</a></span>tsallis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::tsallis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tsallis- <img class="formulaInl" alt="$q$" src="form_21.png"/> entropy of the density matrix <em>A</em>, for <img class="formulaInl" alt="$q\geq 0$" src="form_22.png"/>. </p>
<dl class="section note"><dt>Note</dt><dd>When <img class="formulaInl" alt="$ q\to 1$" src="form_23.png"/> the Tsallis entropy converges to the von-Neumann entropy, with the logarithm in base <img class="formulaInl" alt="$ e $" src="form_24.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">q</td><td>Non-negative real number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tsallis- <img class="formulaInl" alt="$q$" src="form_21.png"/> entropy </dd></dl>

</div>
</div>
<a id="a0439ba7f33753937fee671afe3250554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0439ba7f33753937fee671afe3250554">&#9670;&nbsp;</a></span>tsallis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::tsallis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tsallis- <img class="formulaInl" alt="$q$" src="form_21.png"/> entropy of the probability distribution <em>prob</em>, for <img class="formulaInl" alt="$q\geq 0$" src="form_22.png"/>. </p>
<dl class="section note"><dt>Note</dt><dd>When <img class="formulaInl" alt="$ q\to 1$" src="form_23.png"/> the Tsallis entropy converges to the Shannon entropy, with the logarithm in base <img class="formulaInl" alt="$ e $" src="form_24.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>Real probability vector </td></tr>
    <tr><td class="paramname">q</td><td>Non-negative real number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tsallis- <img class="formulaInl" alt="$q$" src="form_21.png"/> entropy </dd></dl>

</div>
</div>
<a id="abc09834bbfdd7aebe3cd95d01c99b869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc09834bbfdd7aebe3cd95d01c99b869">&#9670;&nbsp;</a></span>uniform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniform probability distribution vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Size of the alphabet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of a uniform distribution of size <em>N</em> </dd></dl>

</div>
</div>
<a id="a88a9f78049d7bf991a2d3c9bd81a05dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a9f78049d7bf991a2d3c9bd81a05dd">&#9670;&nbsp;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::var </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structqpp_1_1is__iterable.html">is_iterable</a>&lt; Container &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>Real probability vector representing the probability distribution of <em>X</em> </td></tr>
    <tr><td class="paramname">X</td><td>Real random variable values represented by an STL-like container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variance of <em>X</em> </dd></dl>

</div>
</div>
<a id="ace6723d802f5d4c15f0d14fa1abee7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6723d802f5d4c15f0d14fa1abee7bb">&#9670;&nbsp;</a></span>x2contfrac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; qpp::x2contfrac </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a>&#160;</td>
          <td class="paramname"><em>cut</em> = <code>1e5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple continued fraction expansion. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a33f4dd20b7c8cdd7d07c596e5b83ee2e" title="Real representation of a simple continued fraction. ">qpp::contfrac2x()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Real number </td></tr>
    <tr><td class="paramname">N</td><td>Maximum number of terms in the expansion </td></tr>
    <tr><td class="paramname">cut</td><td>Stop the expansion when the next term is greater than <em>cut</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer vector containing the simple continued fraction expansion of <em>x</em>. If there are <em>M</em> less than <em>N</em> terms in the expansion, a shorter vector with <em>M</em> components is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3a6d2c509bdcf240869e1bebb3be4e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6d2c509bdcf240869e1bebb3be4e94">&#9670;&nbsp;</a></span>chop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::chop = 1e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in <a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d" title="Eigen expression ostream manipulator. ">qpp::disp()</a> for setting to zero numbers that have their absolute value smaller than <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94" title="Used in qpp::disp() for setting to zero numbers that have their absolute value smaller than qpp::chop...">qpp::chop</a>. </p>

</div>
</div>
<a id="aca5c7e10fa94db0755cb937250144630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5c7e10fa94db0755cb937250144630">&#9670;&nbsp;</a></span>ee</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::ee = 2.718281828459045235360287471352662497</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base of natural logarithm, <img class="formulaInl" alt="$e$" src="form_13.png"/>. </p>

</div>
</div>
<a id="a9a99ccccd473a9006dfaadb5761ac4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a99ccccd473a9006dfaadb5761ac4f6">&#9670;&nbsp;</a></span>eps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::eps = 1e-12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to decide whether a number or expression in double precision is zero or not. </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(std::abs(x) &lt; <a class="code" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6">qpp::eps</a>) <span class="comment">// x is zero </span></div></div><!-- fragment --> 
</div>
</div>
<a id="aecd9c0f42f21f1d3b29868b6a8cac4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd9c0f42f21f1d3b29868b6a8cac4c7">&#9670;&nbsp;</a></span>infty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::infty = std::numeric_limits&lt;double&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to denote infinity in double precision. </p>

</div>
</div>
<a id="aea80be6c57ee43e43aa9629942cd3608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea80be6c57ee43e43aa9629942cd3608">&#9670;&nbsp;</a></span>maxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceqpp.html#a1f5f7137e8551cf82db04d3b81cdd706">idx</a> qpp::maxn = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of allowed qubits/qudits (subsystems) </p>
<p>Used internally to allocate arrays on the stack (for performance reasons): </p>

</div>
</div>
<a id="a73c04db6f636b236d64fddb069bef492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c04db6f636b236d64fddb069bef492">&#9670;&nbsp;</a></span>pi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::pi = 3.141592653589793238462643383279502884</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><img class="formulaInl" alt="$ \pi $" src="form_12.png"/> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceqpp.html">qpp</a></li>
    <li class="footer">Generated on Tue Jul 3 2018 18:05:38 for Quantum++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
